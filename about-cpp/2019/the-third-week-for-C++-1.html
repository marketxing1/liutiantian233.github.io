<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="基于Primer第三周的笔记-1"><meta name="keywords" content="C++的开发和进度"><meta name="author" content="TianTian"><meta name="copyright" content="TianTian"><title>基于Primer第三周的笔记-1 | Tian's 404 WebSite</title><link rel="shortcut icon" href="/melody-favicon.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">1.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数基础"><span class="toc-number">2.</span> <span class="toc-text">函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#编写函数"><span class="toc-number">2.1.</span> <span class="toc-text">编写函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用函数"><span class="toc-number">2.2.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#形参和实参"><span class="toc-number">2.3.</span> <span class="toc-text">形参和实参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的形参列表"><span class="toc-number">2.4.</span> <span class="toc-text">函数的形参列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数返回类型"><span class="toc-number">2.5.</span> <span class="toc-text">函数返回类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#局部对象"><span class="toc-number">3.</span> <span class="toc-text">局部对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#自动对象"><span class="toc-number">3.1.</span> <span class="toc-text">自动对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#局部静态对象"><span class="toc-number">3.2.</span> <span class="toc-text">局部静态对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数声明"><span class="toc-number">4.</span> <span class="toc-text">函数声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在头文件中进行函数声明"><span class="toc-number">4.1.</span> <span class="toc-text">在头文件中进行函数声明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分离式编译"><span class="toc-number">5.</span> <span class="toc-text">分离式编译</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#编译和链接多个源文件"><span class="toc-number">5.1.</span> <span class="toc-text">编译和链接多个源文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参数传递"><span class="toc-number">6.</span> <span class="toc-text">参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#传值参数"><span class="toc-number">6.1.</span> <span class="toc-text">传值参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指针形参"><span class="toc-number">6.1.1.</span> <span class="toc-text">指针形参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传引用参数"><span class="toc-number">6.2.</span> <span class="toc-text">传引用参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用引用避免拷贝"><span class="toc-number">6.2.1.</span> <span class="toc-text">使用引用避免拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用引用形参返回额外信息"><span class="toc-number">6.2.2.</span> <span class="toc-text">使用引用形参返回额外信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-形参和实参"><span class="toc-number">6.3.</span> <span class="toc-text">const 形参和实参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指针或引用形参与-const"><span class="toc-number">6.3.1.</span> <span class="toc-text">指针或引用形参与 const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量使用常量引用"><span class="toc-number">6.3.2.</span> <span class="toc-text">尽量使用常量引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组形参"><span class="toc-number">6.4.</span> <span class="toc-text">数组形参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-处理命令行选项"><span class="toc-number">6.5.</span> <span class="toc-text">main: 处理命令行选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#含有可变形参的参数"><span class="toc-number">6.6.</span> <span class="toc-text">含有可变形参的参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#返回类型和-return-语句"><span class="toc-number">7.</span> <span class="toc-text">返回类型和 return 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#无返回值函数"><span class="toc-number">7.1.</span> <span class="toc-text">无返回值函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有返回值函数"><span class="toc-number">7.2.</span> <span class="toc-text">有返回值函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#值是如何被返回的"><span class="toc-number">7.2.1.</span> <span class="toc-text">值是如何被返回的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要返回局部对象的引用或指针"><span class="toc-number">7.2.2.</span> <span class="toc-text">不要返回局部对象的引用或指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用运算符"><span class="toc-number">7.2.3.</span> <span class="toc-text">调用运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用返回左值"><span class="toc-number">7.2.4.</span> <span class="toc-text">引用返回左值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表初始化返回值"><span class="toc-number">7.2.5.</span> <span class="toc-text">列表初始化返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主函数-main-的返回值"><span class="toc-number">7.2.6.</span> <span class="toc-text">主函数 main 的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归"><span class="toc-number">7.2.7.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#返回数组指针"><span class="toc-number">7.3.</span> <span class="toc-text">返回数组指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考链接"><span class="toc-number">8.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/head.png"></div><div class="author-info__name text-center">TianTian</div><div class="author-info__description text-center">Have a Pair of Black Eyes</div><div class="follow-button"><a href="https://github.com/liutiantian233">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">16</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.zhihu.com/people/wo-de-hei-yan-jing/activities">Zhihu</a><a class="author-info-links__name text-center" href="https://space.bilibili.com/32160272">Bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/liutiantian233/Blog/master/Pic.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Tian's 404 WebSite</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home 主页</a><a class="site-page" href="/about">About 关于</a><a class="site-page" href="/tags">Tags 标签</a><a class="site-page" href="/categories">Categories 分类</a><a class="site-page" href="/archives">Archives 归档</a></span></div><div id="post-info"><div id="post-title">基于Primer第三周的笔记-1</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/about-cpp/">关于C++的学习手册</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.5k</span><span class="post-meta__separator">|</span><span>Reading time: 11 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-2.jpg" alt></p>
<p>这是基于C++ Primer的第三周笔记，主要内容为C++的函数和更多的程序类型。包括函数基础，参数传递，返回类型，复合类型，处理类型，引用和指针。详细请见C++ Primer的6.1节至6.3节，2.3节至2.5节。</p>
<a id="more"></a>
<p>函数是一个命名的代码块，通过调用函数执行相应代码。函数可以有 0 个或多个参数，而且（通常）会产生一个结果。可以重载函数，也就是说，同一个名字可以对应几个不同的函数。</p>
<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><p>一个典型的<strong>函数（function）</strong>定义包括以下部分：<strong>返回类型（return type）</strong>，函数名字，由 0 个或多个<strong>形参（parameter）</strong>组成的列表以及函数体。其中，形参以逗号隔开，形参的列表对于一对圆括号之内。函数执行的操作在语句块中说明，该语句块称为<strong>函数体（function body）</strong>。</p>
<p>我们通过<strong>调用运算符（call operator）</strong>来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针：圆括号之内是一个用逗号隔开的<strong>实参（argument）</strong>列表，用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。</p>
<h2 id="编写函数"><a href="#编写函数" class="headerlink" title="编写函数"></a>编写函数</h2><p>编写一个求数的阶乘的程序。n 的阶乘是从 1 到 n 所有数字的乘积。</p>
<p>程序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;          <span class="comment">// 局部变量，用于保存计算结果</span></span><br><span class="line">    <span class="keyword">while</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">        ret *= val --;    <span class="comment">// 把 ret 和 val 的乘积赋给 ret, 然后 val 减一</span></span><br><span class="line">    <span class="keyword">return</span> ret;           <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的名字是 fact，作用于一个整型参数，返回一个整型值。在 while 循环内部，在每次迭代时用后置递减运算符将 val 的值减一。return 语句负责结束 fact 并返回 ret 的值。</p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>要调用 fact 函数，必须提供一个整数值，调用得到的结果也是一个整数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = fact(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5! is "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，<strong>主调函数（calling function）</strong>的执行被暂时中断，<strong>被调函数（called function）</strong>开始执行。</p>
<h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>实参是形参的初始值。尽管实参于形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任何可行的顺序对实参求值。</p>
<p>实参的类型必须与对应的形参类型匹配。函数有几个形参，就必须提供相同数量的实参。因为函数的调用规定实参数量应与形参数量一致，所以形参一定会被初始化。</p>
<h2 id="函数的形参列表"><a href="#函数的形参列表" class="headerlink" title="函数的形参列表"></a>函数的形参列表</h2><p>函数的形参列表可以为空，但是不能省略。想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。也可以使用关键字 void 表示函数没有形参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125;        <span class="comment">// 隐式的定义空形参列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;    <span class="comment">// 显式的定义空形参列表</span></span><br></pre></td></tr></table></figure>
<p>任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-3.png" alt></p>
<h2 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h2><p>大多数类型都能用作函数的返回类型。一种特殊的返回类型是 void，它表示函数不返回任何值。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。</p>
<h1 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h1><p>在C++语言中，名字有作用域，对象有<strong>生命周期（lifetime）</strong>。</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见。</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-4.png" alt></p>
<h2 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-5.png" alt></p>
<h2 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-6.png" alt></p>
<p>如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为 0 。</p>
<h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><p>和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。</p>
<p>函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号代替即可。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-7.png" alt></p>
<h2 id="在头文件中进行函数声明"><a href="#在头文件中进行函数声明" class="headerlink" title="在头文件中进行函数声明"></a>在头文件中进行函数声明</h2><p>我们建议变量在头文件中声明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。</p>
<p>看起来把函数的声明直接放在使用该函数的源文件中是合法的，也比较容易被人接受；但是这么做可能会很繁琐而且容易出错。相反，如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。</p>
<p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-8.png" alt></p>
<h1 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h1><p>随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。为了允许编写程序时按照逻辑关系将其划分开来，C++语言支持所谓的<strong>分离式编译（separate compilation）</strong>。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。</p>
<h2 id="编译和链接多个源文件"><a href="#编译和链接多个源文件" class="headerlink" title="编译和链接多个源文件"></a>编译和链接多个源文件</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-9.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-10.png" alt></p>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>如前所述，每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-11.png" alt></p>
<p>和其他变量一样，形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-12.png" alt></p>
<h2 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h2><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;   <span class="comment">// int 类型的初始变量</span></span><br><span class="line"><span class="keyword">int</span> i = n;   <span class="comment">// i 是 n 的值的副本</span></span><br><span class="line">i = <span class="number">42</span>;      <span class="comment">// i 的值改变，n 的值不变</span></span><br></pre></td></tr></table></figure>
<p>传值参数的机理完全一样，函数对形参做的所有操作都不会影响实参。</p>
<h3 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h3><p>指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;n, *q = &amp;i;  <span class="comment">// p 指向 n; q 指向 i</span></span><br><span class="line">*p = <span class="number">42</span>;               <span class="comment">// n 的值改变; p 不变</span></span><br><span class="line">p = q                  <span class="comment">// p 现在指向了 i; 但是 i 和 n 的值都不变</span></span><br></pre></td></tr></table></figure>
<p>指针形参的行为与之类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数接受一个指针, 然后将指针所指的值置为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *ip)</span> </span>&#123;</span><br><span class="line">    *ip = <span class="number">0</span>;  <span class="comment">// 改变指针 ip 所指对象的值</span></span><br><span class="line">    ip = <span class="number">0</span>;   <span class="comment">// 只改变了 ip 的局部拷贝, 实参未被改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 reset 函数之后，实参所指的对象被置为 0，但是实参本身并没有改变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">reset(&amp;i);          <span class="comment">// 改变 i 的值而非 i 的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-13.png" alt></p>
<h2 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h2><p>回忆过去所学的知识，我们知道对于引用的操作实际上是作用在引用所引的对象上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = n;  <span class="comment">// r 绑定了 n（即 r 是 n 的另外一个名字）</span></span><br><span class="line">r = <span class="number">42</span>;      <span class="comment">// 现在 n 的值是 42</span></span><br><span class="line">r = i;       <span class="comment">// 现在 n 的值和 i 相同</span></span><br><span class="line">i = r;       <span class="comment">// i 的值和 n 相同</span></span><br></pre></td></tr></table></figure>
<p>引用形参的行为与之类似。通过使用引用形参，允许函数改变一个或多个实参的值。</p>
<p>举个例子，改写上一节的 reset 程序，使其接受的参数是引用类型而非指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数接受一个 int 对象的引用, 然后将对象的值置为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;i)</span> </span>&#123;  <span class="comment">// i 是传给 reset 函数的对象的另一个名字</span></span><br><span class="line">    i = <span class="number">0</span>;            <span class="comment">// 改变了 i 所引对象的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-14.png" alt></p>
<h3 id="使用引用避免拷贝"><a href="#使用引用避免拷贝" class="headerlink" title="使用引用避免拷贝"></a>使用引用避免拷贝</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-15.png" alt></p>
<p>举个例子，准备编写一个函数比较两个 string 对象的长度。因为 string 对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。又因为比较长度无须改变 string 对象的内容，所以把形参定义成对常量的引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较两个 string 对象的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数无须修改引用形参的值时最好使用常量引用。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-16.png" alt></p>
<h3 id="使用引用形参返回额外信息"><a href="#使用引用形参返回额外信息" class="headerlink" title="使用引用形参返回额外信息"></a>使用引用形参返回额外信息</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-17.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-18.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 s 中 c 第一次出现的位置索引</span></span><br><span class="line"><span class="comment">// 引用形参 occurs 负责统计 c 出现的总次数</span></span><br><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">find_char</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">char</span> c, <span class="built_in">string</span>::size_type &amp;occurs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = s.size();  <span class="comment">// 第一次出现的位置（如果有的话）</span></span><br><span class="line">    occurs = <span class="number">0</span>;           <span class="comment">// 设置表示出现次数的形参的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">decltype</span>(ret) i = <span class="number">0</span>; i != s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret == s.size())</span><br><span class="line">                ret = i;  <span class="comment">// 记录 c 第一次出现的位置</span></span><br><span class="line">            ++occurs;     <span class="comment">// 将出现的次数加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;           <span class="comment">// 出现次数通过 occurs 隐式地返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用 find_char 函数时，必须传入三个实参：作为查找范围的一个 string 对象，要找的字符以及一个用于保存字符出现次数的 size_type 对象。假设 s 是一个 string 对象，ctr 是一个 size_type 对象，则我们通过如下形式调用 find_char 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> index = find_char(s, <span class="string">'o'</span>, ctr);</span><br></pre></td></tr></table></figure>
<p>调用完成后，如果 string 对象中确实存在 o，那么 ctr 的值就是 o 出现的次数，index 指向 o 第一次出现的位置；否则如果 string 对象中没有 o，index 等于 s.size() 而 ctr 等于 0 。</p>
<h2 id="const-形参和实参"><a href="#const-形参和实参" class="headerlink" title="const 形参和实参"></a>const 形参和实参</h2><p>当形参是 const 时，必须要注意关于顶层 const 的讨论。顶层 const 作用于对象本身：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;  <span class="comment">// 不能改变 ci, const 是顶层的</span></span><br><span class="line"><span class="keyword">int</span> i = ci;         <span class="comment">// 正确: 当拷贝 ci 时, 忽略了它的顶层 const</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;  <span class="comment">// const 是顶层的, 不能给 p 赋值</span></span><br><span class="line">*p = <span class="number">0</span>;             <span class="comment">// 正确: 通过 p 改变对象的内容是允许的, 现在 i 变成了 0</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-19.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* fcn 能够读取 i, 但是不能向 i 写值 */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-20.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* fcn 能够读取 i, 但是不能向 i 写值 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;      <span class="comment">// 错误: 重复定义了 fcn(int)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-21.png" alt></p>
<h3 id="指针或引用形参与-const"><a href="#指针或引用形参与-const" class="headerlink" title="指针或引用形参与 const"></a>指针或引用形参与 const</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-22.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cp = &amp;i;  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = i;    <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">int</span> *p = cp;         <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = r;         <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = <span class="number">42</span>;        <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>将同样的初始化规则应用到参数传递上可得如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="built_in">string</span>::size_type ctr = <span class="number">0</span>;</span><br><span class="line">reset(&amp;i);        <span class="comment">// 调用形参类型是 int* 的 reset 函数</span></span><br><span class="line">reset(&amp;ci);       <span class="comment">// 错误</span></span><br><span class="line">reset(i);         <span class="comment">// 调用形参类型是 int&amp; 的 reset 函数</span></span><br><span class="line">reset(ci);        <span class="comment">// 错误</span></span><br><span class="line">reset(<span class="number">42</span>);        <span class="comment">// 错误</span></span><br><span class="line">reset(ctr);       <span class="comment">// 错误</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">find_char(<span class="string">"Hello World!"</span>, <span class="string">'o'</span>, ctr);</span><br></pre></td></tr></table></figure>
<h3 id="尽量使用常量引用"><a href="#尽量使用常量引用" class="headerlink" title="尽量使用常量引用"></a>尽量使用常量引用</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-23.png" alt></p>
<h2 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-24.png" alt></p>
<h2 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="headerlink" title="main: 处理命令行选项"></a>main: 处理命令行选项</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-25.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-26.png" alt></p>
<h2 id="含有可变形参的参数"><a href="#含有可变形参的参数" class="headerlink" title="含有可变形参的参数"></a>含有可变形参的参数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-27.png" alt></p>
<h1 id="返回类型和-return-语句"><a href="#返回类型和-return-语句" class="headerlink" title="返回类型和 return 语句"></a>返回类型和 return 语句</h1><p>return 语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。</p>
<p>return 语句有两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>
<h2 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-28.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-29.png" alt></p>
<h2 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h2><p>return 语句的第二种形式提供了函数的结果。只要函数的返回类型不是 void，则该函数内的每条 return 语句必须返回一个值。return 语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-30.png" alt></p>
<h3 id="值是如何被返回的"><a href="#值是如何被返回的" class="headerlink" title="值是如何被返回的"></a>值是如何被返回的</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-31.png" alt></p>
<h3 id="不要返回局部对象的引用或指针"><a href="#不要返回局部对象的引用或指针" class="headerlink" title="不要返回局部对象的引用或指针"></a>不要返回局部对象的引用或指针</h3><p>函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。</p>
<p>返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。</p>
<h3 id="调用运算符"><a href="#调用运算符" class="headerlink" title="调用运算符"></a>调用运算符</h3><p>调用运算符也有优先级和结合律。调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。</p>
<h3 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h3><p>函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-32.png" alt></p>
<h3 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h3><p>C++11 新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p>
<h3 id="主函数-main-的返回值"><a href="#主函数-main-的返回值" class="headerlink" title="主函数 main 的返回值"></a>主函数 main 的返回值</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-33.png" alt></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-34.png" alt></p>
<h2 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h2><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p>
<p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">TianTian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://liutiantian233.github.io/about-cpp/2019/the-third-week-for-C++-1.html">https://liutiantian233.github.io/about-cpp/2019/the-third-week-for-C++-1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPP-development-progress/">C++的开发和进度</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/about-cpp/2019/the-third-week-for-C++-2.html"><i class="fa fa-chevron-left">  </i><span>基于Primer第三周的笔记-2</span></a></div><div class="next-post pull-right"><a href="/about-cpp/2019/the-second-week-for-C++.html"><span>基于Primer第二周的笔记</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '4ac20a893c67158e8447',
  clientSecret: '5d4cb9ac240a2e9fdcac71b718af5dde4901fcc7',
  repo: 'liutiantian233.github.io',
  owner: 'liutiantian233',
  admin: 'liutiantian233',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/liutiantian233/Blog/master/Pic.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By TianTian</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Welcome To My <a href="https://liutiantian233.github.io">Blog</a>! This is TianTian.</div><div class="icp"><a><span>Tian's Lucky Date 3/16</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>