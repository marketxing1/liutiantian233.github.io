<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="基于Primer第四周的笔记"><meta name="keywords" content="C++的开发和进度"><meta name="author" content="TianTian"><meta name="copyright" content="TianTian"><title>基于Primer第四周的笔记 | Tian's 404 WebSite</title><link rel="shortcut icon" href="/melody-favicon.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#命名空间的-using-声明"><span class="toc-number">1.</span> <span class="toc-text">命名空间的 using 声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#每个名字都需要独立的-using-声明"><span class="toc-number">1.1.</span> <span class="toc-text">每个名字都需要独立的 using 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#头文件不应包含-using-声明"><span class="toc-number">1.2.</span> <span class="toc-text">头文件不应包含 using 声明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#标准库类型-string"><span class="toc-number">2.</span> <span class="toc-text">标准库类型 string</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义和初始化-string-对象"><span class="toc-number">3.</span> <span class="toc-text">定义和初始化 string 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#直接初始化和拷贝初始化"><span class="toc-number">3.1.</span> <span class="toc-text">直接初始化和拷贝初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string-对象上的操作"><span class="toc-number">4.</span> <span class="toc-text">string 对象上的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#读写-string-对象"><span class="toc-number">4.1.</span> <span class="toc-text">读写 string 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读取未知数量的-string-对象"><span class="toc-number">4.2.</span> <span class="toc-text">读取未知数量的 string 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-getline-读取一整行"><span class="toc-number">4.3.</span> <span class="toc-text">使用 getline 读取一整行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-的-empty-和-size-操作"><span class="toc-number">4.4.</span> <span class="toc-text">string 的 empty 和 size 操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-size-type-类型"><span class="toc-number">4.5.</span> <span class="toc-text">string::size_type 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#比较-string-对象"><span class="toc-number">4.6.</span> <span class="toc-text">比较 string 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为-string-对象赋值"><span class="toc-number">4.7.</span> <span class="toc-text">为 string 对象赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两个-string-对象相加"><span class="toc-number">4.8.</span> <span class="toc-text">两个 string 对象相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字面值和-string-对象相加"><span class="toc-number">4.9.</span> <span class="toc-text">字面值和 string 对象相加</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#处理-string-对象中的字符"><span class="toc-number">5.</span> <span class="toc-text">处理 string 对象中的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#处理每个字符（使用基于范围的-for-语句）"><span class="toc-number">5.1.</span> <span class="toc-text">处理每个字符（使用基于范围的 for 语句）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用范围-for-语句改变字符串中的字符"><span class="toc-number">5.2.</span> <span class="toc-text">使用范围 for 语句改变字符串中的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#只处理一部分字符"><span class="toc-number">5.3.</span> <span class="toc-text">只处理一部分字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用下标执行迭代"><span class="toc-number">5.4.</span> <span class="toc-text">使用下标执行迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用下标执行随机访问"><span class="toc-number">5.5.</span> <span class="toc-text">使用下标执行随机访问</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#额外的-string-操作"><span class="toc-number">6.</span> <span class="toc-text">额外的 string 操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造-string-的其他方法"><span class="toc-number">7.</span> <span class="toc-text">构造 string 的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#substr-操作"><span class="toc-number">7.1.</span> <span class="toc-text">substr 操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#改变-string-的其他方法"><span class="toc-number">8.</span> <span class="toc-text">改变 string 的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#append-和-replace-函数"><span class="toc-number">8.1.</span> <span class="toc-text">append 和 replace 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#改变-string-的多种重载函数"><span class="toc-number">8.2.</span> <span class="toc-text">改变 string 的多种重载函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string-搜索操作"><span class="toc-number">9.</span> <span class="toc-text">string 搜索操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#指定在哪里开始搜索"><span class="toc-number">9.1.</span> <span class="toc-text">指定在哪里开始搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逆向搜索"><span class="toc-number">9.2.</span> <span class="toc-text">逆向搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#compare-函数"><span class="toc-number">10.</span> <span class="toc-text">compare 函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值转换"><span class="toc-number">11.</span> <span class="toc-text">数值转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考链接"><span class="toc-number">12.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/head.png"></div><div class="author-info__name text-center">TianTian</div><div class="author-info__description text-center">Have a Pair of Black Eyes</div><div class="follow-button"><a href="https://github.com/liutiantian233">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">16</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.zhihu.com/people/wo-de-hei-yan-jing/activities">Zhihu</a><a class="author-info-links__name text-center" href="https://space.bilibili.com/32160272">Bilibili</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/liutiantian233/Blog/master/Pic.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Tian's 404 WebSite</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home 主页</a><a class="site-page" href="/about">About 关于</a><a class="site-page" href="/tags">Tags 标签</a><a class="site-page" href="/categories">Categories 分类</a><a class="site-page" href="/archives">Archives 归档</a></span></div><div id="post-info"><div id="post-title">基于Primer第四周的笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-02-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/about-cpp/">关于C++的学习手册</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.9k</span><span class="post-meta__separator">|</span><span>Reading time: 9 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="命名空间的-using-声明"><a href="#命名空间的-using-声明" class="headerlink" title="命名空间的 using 声明"></a>命名空间的 using 声明</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-1.jpg" alt></p>
<p>这是基于C++ Primer的第四周笔记，主要内容为C++的字符和字符串的标准模版库。包括命名空间的声明，标准库类型的字符串，处理字符串对象中的字符和额外的字符串操作。详细请见C++ Primer的3.1节至3.2节和9.5节。</p>
<a id="more"></a>
<p>目前为止，我们用到的库函数基本上都属于命名空间的 std，而程序也显式地将这一点标示了出来。例如，std::cin 表示从标准输入中读取内容。此处使用作用域操作符（::）的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。因此，std::cin 的意思就是要使用命名空间 std 中的名字 cin。</p>
<p>上面的方法显得比较繁琐，然而幸运的是，通过更简单的途径也能使用到命名空间中的成员。也就是使用 <strong>using 声明（using declaration）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-2.png" alt></p>
<h2 id="每个名字都需要独立的-using-声明"><a href="#每个名字都需要独立的-using-声明" class="headerlink" title="每个名字都需要独立的 using 声明"></a>每个名字都需要独立的 using 声明</h2><p>按照规定，每个 using 声明引入命名空间中的一个成员。例如，可以把要用到的标准库中的名字都以 using 声明的形式表示出来，重写的程序如下：</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-3.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-4.png" alt></p>
<h2 id="头文件不应包含-using-声明"><a href="#头文件不应包含-using-声明" class="headerlink" title="头文件不应包含 using 声明"></a>头文件不应包含 using 声明</h2><p>位于头文件的代码一般来说不应该使用 using 声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个 using 声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p>
<h1 id="标准库类型-string"><a href="#标准库类型-string" class="headerlink" title="标准库类型 string"></a>标准库类型 string</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-5.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-6.png" alt></p>
<h1 id="定义和初始化-string-对象"><a href="#定义和初始化-string-对象" class="headerlink" title="定义和初始化 string 对象"></a>定义和初始化 string 对象</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-7.png" alt></p>
<p>可以通过默认的方式初始化一个 string 对象，这样就会得到一个空的 string，也就是说，该 string 对象中没有任何字符。如果提供了一个字符串字面值，则该字面值中除了最后那个空字符外其他所有的字符都被拷贝到新创建的 string 对象中去。如果提供的是一个数字和一个字符，则 string 对象的内容是给定字符连续重复若干次后得到的序列。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-8.png" alt></p>
<h2 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h2><p>C++语言有几种不同的初始化方式，通过 string 我们可以清晰地看到在这些初始化方式之间到底有什么区别和联系。如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化（copy initialization）</strong>，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是<strong>直接初始化（direct initialization）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-9.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-10.png" alt></p>
<h1 id="string-对象上的操作"><a href="#string-对象上的操作" class="headerlink" title="string 对象上的操作"></a>string 对象上的操作</h1><p>一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，也能定义 <strong>&lt;&lt; +</strong> 等各种运算符在该类对象上的新含义。下表列举了 string 的大多数操作。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-11.png" alt></p>
<h2 id="读写-string-对象"><a href="#读写-string-对象" class="headerlink" title="读写 string 对象"></a>读写 string 对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-12.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-13.png" alt></p>
<h2 id="读取未知数量的-string-对象"><a href="#读取未知数量的-string-对象" class="headerlink" title="读取未知数量的 string 对象"></a>读取未知数量的 string 对象</h2><p>下面编写一个程序用于读取数量未知的 string 对象：</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-14.png" alt></p>
<h2 id="使用-getline-读取一整行"><a href="#使用-getline-读取一整行" class="headerlink" title="使用 getline 读取一整行"></a>使用 getline 读取一整行</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-15.png" alt></p>
<p>和输入运算符一样，getline 也会返回它的流参数。因此既然输入运算符能作为判断条件，我们也能用 getline 的结果作为条件。例如，可以通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了：</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-16.png" alt></p>
<h2 id="string-的-empty-和-size-操作"><a href="#string-的-empty-和-size-操作" class="headerlink" title="string 的 empty 和 size 操作"></a>string 的 empty 和 size 操作</h2><p>顾名思义，<strong>empty</strong> 函数根据 string 对象是否为空返回一个对应的布尔值。empty 是 string 的一个成员函数。调用该函数的方法很简单，只要使用点操作符指明是哪个对象执行了 empty 函数就可以了。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-17.png" alt></p>
<h2 id="string-size-type-类型"><a href="#string-size-type-类型" class="headerlink" title="string::size_type 类型"></a>string::size_type 类型</h2><p>对于 size 函数来说，返回一个 int 或者返回一个 unsigned 似乎都是合情合理的。但其实 size 函数返回的是一个 string::size_type 类型的值，下面就对这种新的类型稍作解释。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-18.png" alt></p>
<p>尽管我们不太清楚 string::size_type 类型的细节，但是有一点是肯定的：它是一个无符号类型的值，而且能足够存放下任何 string 对象的大小。所有用于存放 string 类的 size 函数返回值的变量，都应该是 string::size_type 类型的。</p>
<p>过去，string::size_type 这种类型有点神秘，不太容易理解和使用。在 C++11 新标准中，允许编译器通过 auto 或者 decltype 来推断变量的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = line.size();  <span class="comment">// len 的类型是 string::size_type</span></span><br></pre></td></tr></table></figure>
<p>由于 size 函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设 n 是一个具有负值的 int，则表达式 s.size() &lt; n 的判断结果几乎肯定是 true。这是因为负值 n 会自动地转换成一个比较大的无符号值。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-19.png" alt></p>
<h2 id="比较-string-对象"><a href="#比较-string-对象" class="headerlink" title="比较 string 对象"></a>比较 string 对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-20.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-21.png" alt></p>
<h2 id="为-string-对象赋值"><a href="#为-string-对象赋值" class="headerlink" title="为 string 对象赋值"></a>为 string 对象赋值</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-22.png" alt></p>
<h2 id="两个-string-对象相加"><a href="#两个-string-对象相加" class="headerlink" title="两个 string 对象相加"></a>两个 string 对象相加</h2><p>两个 string 对象相加得到一个新的 string 对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。也就是说，对 string 对象使用加法运算符（+）的结果是一个新的 string 对象，它所包含的字符由两部分组成：前半部分是加号左侧 string 对象所包含的字符，后半部分是加号右侧 string 对象所包含的字符。另外，复合赋值运算符（+=）负责把右侧 string 对象的内容追加到左侧 string 对象的后面：</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-23.png" alt></p>
<h2 id="字面值和-string-对象相加"><a href="#字面值和-string-对象相加" class="headerlink" title="字面值和 string 对象相加"></a>字面值和 string 对象相加</h2><p>即使一种类型并非所需，我们也可以使用它，不过前提是该种类型可以自动转换成所需的类型。因为标准库允许把字符字面值和字符串字面值转换成 string 对象，所以在需要 string 对象的地方就可以使用这两种字面值来代替。利用这一点将之前的程序改写为如下形式：</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-24.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-25.png" alt></p>
<p>s4 和 s5 初始化时只用到了一个加法运算符，因此很容易判断是否合法。s6 的初始化形式之前没有出现过，但其实它的工作机理和连续输入连续输出是一样的，可以用如下的形式分组：</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-26.png" alt></p>
<h1 id="处理-string-对象中的字符"><a href="#处理-string-对象中的字符" class="headerlink" title="处理 string 对象中的字符"></a>处理 string 对象中的字符</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-27.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-28.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-29.png" alt></p>
<h2 id="处理每个字符（使用基于范围的-for-语句）"><a href="#处理每个字符（使用基于范围的-for-语句）" class="headerlink" title="处理每个字符（使用基于范围的 for 语句）"></a>处理每个字符（使用基于范围的 for 语句）</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-30.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-31.png" alt></p>
<p>for 循环把变量 c 和 str 联系了起来，其中我们定义循环控制变量的方式与定义任意一个普通变量是一样的。此例子，通过使用 auto 关键字让编译器来决定变量 c 的类型，这里 c 的类型是 char。每次迭代，str 的下一个字符被拷贝给 c，因此该循环可以读作“对于字符串 str 中的每个字符 c，执行某某操作。”此例中的“某某操作”即输出一个字符，然后换行。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-32.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello World!!!"</span>)</span></span>;</span><br><span class="line"><span class="comment">// punct_cnt 的类型和 s.size() 的返回类型一样</span></span><br><span class="line"><span class="keyword">decltype</span> (s.size()) punct_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 统计 s 中标点符号的数量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)        <span class="comment">// 对于 s 中的每个字符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))     <span class="comment">// 如果该字符是标点符号</span></span><br><span class="line">        ++punct_cnt;    <span class="comment">// 将标点符号的计数值加一</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; punct_cnt &lt;&lt; <span class="string">" punctuation characters in "</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-33.png" alt></p>
<p>这里我们使用 decltype 关键字声明计数变量 punct_cnt，它的类型是 s.size() 函数返回值的类型，也就是 string::size_type。使用范围 for 语句处理 string 对象中的每个字符并检查其是否是标点符号。如果是，使用递增运算符给计数变量加一。最后，待范围 for 语句结束后输出统计结果。</p>
<h2 id="使用范围-for-语句改变字符串中的字符"><a href="#使用范围-for-语句改变字符串中的字符" class="headerlink" title="使用范围 for 语句改变字符串中的字符"></a>使用范围 for 语句改变字符串中的字符</h2><p>如果想要改变 string 对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-34.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-35.png" alt></p>
<h2 id="只处理一部分字符"><a href="#只处理一部分字符" class="headerlink" title="只处理一部分字符"></a>只处理一部分字符</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-36.png" alt></p>
<p>要想访问 string 对象中的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。</p>
<p><strong>下标运算符 [ ] </strong>接收的输入参数是 string::size_type 类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-37.png" alt></p>
<p>下标的值称作“下标”或<strong>“索引”</strong>，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由 string::size_type 表达的无符号类型。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-38.png" alt></p>
<p>只要字符串不是常量，就能为下标运算符返回的字符赋新值。例如，下面的程序将字符串的首字符改成了大写形式：</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-39.png" alt></p>
<h2 id="使用下标执行迭代"><a href="#使用下标执行迭代" class="headerlink" title="使用下标执行迭代"></a>使用下标执行迭代</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-40.png" alt></p>
<h2 id="使用下标执行随机访问"><a href="#使用下标执行随机访问" class="headerlink" title="使用下标执行随机访问"></a>使用下标执行随机访问</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-41.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-42.png" alt></p>
<p>上述程序的执行过程是这样的：首先初始化变量 hexdigits 令其存放从 0 到 F 的十六进制数字，注意我们把 hexdigits 声明成了常量，这是因为在后面的程序中不打算再改变它的值。在循环内部使用输入值 n 作为 hexdigits 的下标，hexdigits [n] 的值就是 hexdigits 内位置 n 处的字符。例如，如果 n 是 15，则结果是 F，如果 n 是 12，则结果是 C，以此类推。把得到的十六进制数字添加到 result 内，最后一并输出。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-43.png" alt></p>
<h1 id="额外的-string-操作"><a href="#额外的-string-操作" class="headerlink" title="额外的 string 操作"></a>额外的 string 操作</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-44.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-45.png" alt></p>
<h1 id="构造-string-的其他方法"><a href="#构造-string-的其他方法" class="headerlink" title="构造 string 的其他方法"></a>构造 string 的其他方法</h1><p>除了已经介绍过的构造函数，以及与其他顺序容器相同的构造函数外，string 类型还支持另外三个构造函数，如下表所示。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-46.png" alt></p>
<p>当从一个 string 拷贝字符时，我们可以提供一个可选的开始位置和一个计数值。开始位置必须小于或者等于给定的 string 的大小。如果位置大于 size，则构造函数抛出一个 out_of_range 异常。如果我们传递了一个计数值，则从给定位置开始拷贝这么多个字符。不管我们要求拷贝多少个字符，标准库最多拷贝到 string 结尾，不会更多。</p>
<h2 id="substr-操作"><a href="#substr-操作" class="headerlink" title="substr 操作"></a>substr 操作</h2><p>substr 操作返回一个 string，它是原始 string 的一部分或者全部的拷贝。可以传递给 substr 一个可选的开始位置和计数值：</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-47.png" alt></p>
<p>如果开始位置超过了 string 的大小，则 substr 函数抛出一个 out_of_range 异常。如果开始位置加上计数值大于 string 的大小，则 substr 会调整计数值，只会拷贝到 string 的末尾。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-48.png" alt></p>
<h1 id="改变-string-的其他方法"><a href="#改变-string-的其他方法" class="headerlink" title="改变 string 的其他方法"></a>改变 string 的其他方法</h1><p>string 类型支持顺序容器的赋值运算符以及 assign insert 和 erase 操作。除此之外，它还定义了额外的 insert 和 erase 版本。</p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-49.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-50.png" alt></p>
<h2 id="append-和-replace-函数"><a href="#append-和-replace-函数" class="headerlink" title="append 和 replace 函数"></a>append 和 replace 函数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-51.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-52.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-53.png" alt></p>
<h2 id="改变-string-的多种重载函数"><a href="#改变-string-的多种重载函数" class="headerlink" title="改变 string 的多种重载函数"></a>改变 string 的多种重载函数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-54.png" alt></p>
<h1 id="string-搜索操作"><a href="#string-搜索操作" class="headerlink" title="string 搜索操作"></a>string 搜索操作</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-55.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-56.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-57.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-58.png" alt></p>
<h2 id="指定在哪里开始搜索"><a href="#指定在哪里开始搜索" class="headerlink" title="指定在哪里开始搜索"></a>指定在哪里开始搜索</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-59.png" alt></p>
<h2 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-60.png" alt></p>
<h1 id="compare-函数"><a href="#compare-函数" class="headerlink" title="compare 函数"></a>compare 函数</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-61.png" alt></p>
<h1 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-62.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-63.png" alt></p>
<p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-64.png" alt></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p>
<p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">TianTian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://liutiantian233.github.io/about-cpp/2019/the-fourth-week-for-C++.html">https://liutiantian233.github.io/about-cpp/2019/the-fourth-week-for-C++.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPP-development-progress/">C++的开发和进度</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/about-cpp/2019/the-fifth-week-for-C++-1.html"><i class="fa fa-chevron-left">  </i><span>基于Primer第五周的笔记-1</span></a></div><div class="next-post pull-right"><a href="/about-cpp/2019/the-third-week-for-C++-2.html"><span>基于Primer第三周的笔记-2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '4ac20a893c67158e8447',
  clientSecret: '5d4cb9ac240a2e9fdcac71b718af5dde4901fcc7',
  repo: 'liutiantian233.github.io',
  owner: 'liutiantian233',
  admin: 'liutiantian233',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/liutiantian233/Blog/master/Pic.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By TianTian</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Welcome To My <a href="https://liutiantian233.github.io">Blog</a>! This is TianTian.</div><div class="icp"><a><span>Tian's Lucky Date 3/16</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>