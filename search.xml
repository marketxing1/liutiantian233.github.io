<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于Primer第七周的笔记-2</title>
      <link href="/about-cpp/2019/the-seventh-week-for-C++-2.html"/>
      <url>/about-cpp/2019/the-seventh-week-for-C++-2.html</url>
      
        <content type="html"><![CDATA[<h1 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/seventh-week-1.png" alt></p><p>这是基于C++ Primer的第七周笔记，主要内容为C++的String流，try语句块，异常处理，容器库概览和迭代器。包括throw表达式，抛出异常，捕获异常，异常类层次，容器类型成员，容器定义和初始化，插入迭代器和反向迭代器等。详细请见C++ Primer的8.3节，5.6节，18.1节，9.2节和10.4节。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Primer第七周的笔记-1</title>
      <link href="/about-cpp/2019/the-seventh-week-for-C++-1.html"/>
      <url>/about-cpp/2019/the-seventh-week-for-C++-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="String-流"><a href="#String-流" class="headerlink" title="String 流"></a>String 流</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/seventh-week-1.png" alt></p><p>这是基于C++ Primer的第七周笔记，主要内容为C++的String流，try语句块，异常处理，容器库概览和迭代器。包括throw表达式，抛出异常，捕获异常，异常类层次，容器类型成员，容器定义和初始化，插入迭代器和反向迭代器等。详细请见C++ Primer的8.3节，5.6节，18.1节，9.2节和10.4节。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Primer第六周的笔记</title>
      <link href="/about-cpp/2019/the-sixth-week-for-C++.html"/>
      <url>/about-cpp/2019/the-sixth-week-for-C++.html</url>
      
        <content type="html"><![CDATA[<h1 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-1.png" alt></p><p>这是基于C++ Primer的第六周笔记，主要内容为C++的头文件和Vector。包括自定义数据结构，函数基础和标准库类型的Vector。详细请见C++ Primer的2.6节，6.1节和3.3节。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-2.png" alt></p><h1 id="定义-Sales-data-类型"><a href="#定义-Sales-data-类型" class="headerlink" title="定义 Sales_data 类型"></a>定义 Sales_data 类型</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-3.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-4.png" alt></p><h2 id="类数据成员"><a href="#类数据成员" class="headerlink" title="类数据成员"></a>类数据成员</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-5.png" alt></p><h1 id="使用-Sales-data-类"><a href="#使用-Sales-data-类" class="headerlink" title="使用 Sales_data 类"></a>使用 Sales_data 类</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-6.png" alt></p><h2 id="添加两个-Sales-data-对象"><a href="#添加两个-Sales-data-对象" class="headerlink" title="添加两个 Sales_data 对象"></a>添加两个 Sales_data 对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-7.png" alt></p><h2 id="Sales-data-对象读入数据"><a href="#Sales-data-对象读入数据" class="headerlink" title="Sales_data 对象读入数据"></a>Sales_data 对象读入数据</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-8.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-9.png" alt></p><h2 id="输出两个-Sales-data-对象的和"><a href="#输出两个-Sales-data-对象的和" class="headerlink" title="输出两个 Sales_data 对象的和"></a>输出两个 Sales_data 对象的和</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-10.png" alt></p><h1 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-11.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-12.png" alt></p><h2 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-13.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-14.png" alt></p><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><p>关于C++ Primer的 6.1 函数基础部分已在第三周笔记中详细介绍。可点击<a href="https://liutiantian233.github.io/about-cpp/2019/the-third-week-for-C++-1.html#函数基础">跳转链接</a>。</p><h1 id="标准库类型-vector"><a href="#标准库类型-vector" class="headerlink" title="标准库类型 vector"></a>标准库类型 vector</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-15.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-16.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-17.png" alt></p><h1 id="定义和初始化-vector-对象"><a href="#定义和初始化-vector-对象" class="headerlink" title="定义和初始化 vector 对象"></a>定义和初始化 vector 对象</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-18.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-19.png" alt></p><h2 id="列表初始化-vector-对象"><a href="#列表初始化-vector-对象" class="headerlink" title="列表初始化 vector 对象"></a>列表初始化 vector 对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-20.png" alt></p><h2 id="创建指定数量的元素"><a href="#创建指定数量的元素" class="headerlink" title="创建指定数量的元素"></a>创建指定数量的元素</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-21.png" alt></p><h2 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-22.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-23.png" alt></p><h2 id="列表初始值还是元素数量？"><a href="#列表初始值还是元素数量？" class="headerlink" title="列表初始值还是元素数量？"></a>列表初始值还是元素数量？</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-24.png" alt></p><h1 id="向-vector-对象中添加元素"><a href="#向-vector-对象中添加元素" class="headerlink" title="向 vector 对象中添加元素"></a>向 vector 对象中添加元素</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-25.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-26.png" alt></p><h2 id="向-vector-对象添加元素蕴含的编程假定"><a href="#向-vector-对象添加元素蕴含的编程假定" class="headerlink" title="向 vector 对象添加元素蕴含的编程假定"></a>向 vector 对象添加元素蕴含的编程假定</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-27.png" alt></p><h1 id="其他-vector-操作"><a href="#其他-vector-操作" class="headerlink" title="其他 vector 操作"></a>其他 vector 操作</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-28.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-29.png" alt></p><h2 id="计算-vector-内对象的索引"><a href="#计算-vector-内对象的索引" class="headerlink" title="计算 vector 内对象的索引"></a>计算 vector 内对象的索引</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-30.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-31.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-32.png" alt></p><h2 id="不能用下标形式添加元素"><a href="#不能用下标形式添加元素" class="headerlink" title="不能用下标形式添加元素"></a>不能用下标形式添加元素</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-33.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/sixth-week-34.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p><p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX基础命令</title>
      <link href="/about-cpp/2019/UNIX-basic-commands.html"/>
      <url>/about-cpp/2019/UNIX-basic-commands.html</url>
      
        <content type="html"><![CDATA[<h1 id="了解终端应用程序"><a href="#了解终端应用程序" class="headerlink" title="了解终端应用程序"></a>了解终端应用程序</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/unix-1.jpg" alt></p><p>UNIX系统中一项最奇特和突出的特性就是其命令行功能。只需输入包含一定逻辑关系的少量文本，即可使用命令行来将有限的UNIX实用工具组合成无限的即时可用的数据转换。</p><a id="more"></a><p>在大多数实验的开始，将是一个关于新技能的部分，以使你在命令行中更加精通。 许多任务只能在终端上执行，或者更容易在终端上执行，因此这会变得很重要。 在此之后将至少基本熟悉命令行，因此请特别注意这些部分。</p><h1 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h1><p>在 UNIX 层次结构中，想要知道当前所处的目录，可以用 <code>pwd</code> 命令，该命令显示整个路径名。</p><h2 id="全称"><a href="#全称" class="headerlink" title="全称"></a>全称</h2><p>Print Working Directory</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>显示工作目录的路径名称</p><h1 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h1><p>在 UNIX 中实现。<code>ls</code> 是英文 list 的缩写，用于列出文件，是 UNIX 系统中使用非常频繁的命令。</p><p>文件夹以 <code>/</code> 结尾，文件不需要。一些终端还将颜色输出添加到 <code>ls</code> 以表示不同类型的文件。</p><h1 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h1><p><code>cd</code> 命令是<strong>更改目录</strong>的缩写。它允许将工作目录更改为某个不同的文件夹。</p><h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p><code>cp</code> 命令用来将一个或多个源文件或者目录<strong>复制</strong>到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。<code>cp</code> 命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。</p><h1 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h1><p><code>mv</code> 命令是 move 的缩写，可以用来移动文件或者将文件改名，是 UNIX 系统下常用的命令，经常用来备份文件或者目录。</p><h1 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h1><p><code>rm</code> 命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。</p><p><strong>注意：如果要删除文件夹，则需要提供 <code>-r</code> 标志</strong></p><h1 id="Pagers"><a href="#Pagers" class="headerlink" title="Pagers"></a>Pagers</h1><p>通常，如果希望能够在终端中查看文件，而不是在文本编辑器中打开它们。有几种方法可以从终端查看文件。</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p><code>cat</code> 是 UNIX 系统下用来查看文件连续内容用的指令，字面上的含意是 <strong>concatenate 连续</strong>的缩写。除了用来作为显示文件内容外，<code>cat</code> 指令也可用于标准流上的处理，如将显示的消息转入或附加另一文件上。</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p><code>less</code> 工具也是对文件或其它输出进行分页显示的工具，应该说是 UNIX 正统查看文件内容的工具，功能极其强大。可以使用 pageup pagedown 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 <code>less</code> 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</p><h1 id="Help"><a href="#Help" class="headerlink" title="Help"></a>Help</h1><p>有一些程序旨在提供有关计算机上安装的程序的文档。但是，它们通常很难理解，特别是对初学者而言。可以通过键入帮助程序和想要了解的程序名称来调用它们。</p><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>此命令用于提供有关 <code>tcsh</code> 的信息。</p><h2 id="man（manual）"><a href="#man（manual）" class="headerlink" title="man（manual）"></a>man（manual）</h2><p><code>man</code> 命令是 UNIX 下的帮助指令，通过 <code>man</code> 指令可以查看 UNIX 中的指令帮助，配置文件帮助和编程帮助等信息。</p><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>此命令是 <code>man</code> 的替代命令，通常由 UNIX 发行版使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">help cd</span><br><span class="line">info ls</span><br><span class="line">man python3</span><br></pre></td></tr></table></figure><h1 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h1><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p><p><a href="http://www.runoob.com/linux/linux-shell-io-redirections.html" target="_blank" rel="noopener">具体中文超链接</a></p><h1 id="命令自动完成"><a href="#命令自动完成" class="headerlink" title="命令自动完成"></a>命令自动完成</h1><p>输入TAB键会自动补全代码</p><h1 id="History"><a href="#History" class="headerlink" title="History"></a>History</h1><p>终端会记住其历史记录中键入的每个命令。执行 <code>history</code> 命令时，终端将使用数字报告每个命令运行。</p><h1 id="PATH"><a href="#PATH" class="headerlink" title="$PATH"></a>$PATH</h1><p>PATH是尝试运行命令时剪切所在目录的列表。shell查看列表中的每个文件夹（按顺序）尝试查找与命令相同的程序。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p><p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
            <tag> UNIX的基础和学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Primer第五周的笔记-2</title>
      <link href="/about-cpp/2019/the-fifth-week-for-C++-2.html"/>
      <url>/about-cpp/2019/the-fifth-week-for-C++-2.html</url>
      
        <content type="html"><![CDATA[<h1 id="IO-库"><a href="#IO-库" class="headerlink" title="IO 库"></a>IO 库</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-1.jpg" alt></p><p>这是基于C++ Primer的第五周笔记，主要内容为C++的函数模版和输出输入的基本标准库。包括函数重载，特殊用途的语言特性，函数模版，IO 类和文件的输入输出。详细请见C++ Primer的6.4节至6.5节，8.1节至8.2节和16.1.1节。</p><a id="more"></a><p>我们的程序已经使用了很多 IO 库设施了。我们已经介绍了大部分 IO 库设施：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-50.png" alt></p><h1 id="IO-类"><a href="#IO-类" class="headerlink" title="IO 类"></a>IO 类</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-51.png" alt></p><h2 id="IO-类型间的关系"><a href="#IO-类型间的关系" class="headerlink" title="IO 类型间的关系"></a>IO 类型间的关系</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-52.png" alt></p><p>标准库使我们能忽略这些不同类型的流之间的差异，这是通过<strong>继承机制（inheritance）</strong>实现的。利用模版，我们可以使用具有继承关系的类，而不必了解继承机制如何工作的细节。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-53.png" alt></p><h1 id="IO-对象无拷贝或赋值"><a href="#IO-对象无拷贝或赋值" class="headerlink" title="IO 对象无拷贝或赋值"></a>IO 对象无拷贝或赋值</h1><p>我们不能拷贝或对 IO 对象赋值：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-54.png" alt></p><p>由于不能拷贝 IO 对象，因此我们也不能将形参或返回类型设置为流类型。进行 IO 操作的函数通常以引用方式传递和返回流。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是 const 的。</p><h1 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-55.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-56.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-57.png" alt></p><h2 id="查询流的状态"><a href="#查询流的状态" class="headerlink" title="查询流的状态"></a>查询流的状态</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-58.png" alt></p><p>IO 库定义了一个与机器无关的 <code>iostate</code> 类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用。IO 库定义了 4 个 <code>iostate</code> 类型的 constexpr 值，表示特定的位模式。这些值用来表示特定类型的 IO 条件，可以与位运算符一起使用来一次性检测或设置多个标志位。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-59.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-60.png" alt></p><h2 id="管理条件状态"><a href="#管理条件状态" class="headerlink" title="管理条件状态"></a>管理条件状态</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-61.png" alt></p><h1 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-62.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-63.png" alt></p><h2 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-64.png" alt></p><h2 id="unitbuf-操纵符"><a href="#unitbuf-操纵符" class="headerlink" title="unitbuf 操纵符"></a>unitbuf 操纵符</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-65.png" alt></p><h2 id="关联输入和输出流"><a href="#关联输入和输出流" class="headerlink" title="关联输入和输出流"></a>关联输入和输出流</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-66.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-67.png" alt></p><h1 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-68.png" alt></p><h1 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-69.png" alt></p><h2 id="用-fstream-代替-iostream-amp"><a href="#用-fstream-代替-iostream-amp" class="headerlink" title="用 fstream 代替 iostream&amp;"></a>用 fstream 代替 iostream&amp;</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-70.png" alt></p><h2 id="成员函数-open-和-close"><a href="#成员函数-open-和-close" class="headerlink" title="成员函数 open 和 close"></a>成员函数 open 和 close</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-71.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-72.png" alt></p><h2 id="自动构造和析构"><a href="#自动构造和析构" class="headerlink" title="自动构造和析构"></a>自动构造和析构</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-73.png" alt></p><h1 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-74.png" alt></p><h2 id="以-out-模式打开文件会丢弃已有数据"><a href="#以-out-模式打开文件会丢弃已有数据" class="headerlink" title="以 out 模式打开文件会丢弃已有数据"></a>以 out 模式打开文件会丢弃已有数据</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-75.png" alt></p><h2 id="每次调用-open-时都会确定文件模式"><a href="#每次调用-open-时都会确定文件模式" class="headerlink" title="每次调用 open 时都会确定文件模式"></a>每次调用 open 时都会确定文件模式</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-76.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p><p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Primer第五周的笔记-1</title>
      <link href="/about-cpp/2019/the-fifth-week-for-C++-1.html"/>
      <url>/about-cpp/2019/the-fifth-week-for-C++-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-1.jpg" alt></p><p>这是基于C++ Primer的第五周笔记，主要内容为C++的函数模版和输出输入的基本标准库。包括函数重载，特殊用途的语言特性，函数模版，IO 类和文件的输入输出。详细请见C++ Primer的6.4节至6.5节，8.1节至8.2节和16.1.1节。</p><a id="more"></a><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为<strong>重载（overloaded）函数</strong>。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-2.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-3.png" alt></p><h2 id="定义重载函数"><a href="#定义重载函数" class="headerlink" title="定义重载函数"></a>定义重载函数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-4.png" alt></p><h2 id="判断两个形参的类型是否相异"><a href="#判断两个形参的类型是否相异" class="headerlink" title="判断两个形参的类型是否相异"></a>判断两个形参的类型是否相异</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-5.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-6.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-7.png" alt></p><h2 id="重载和-const-形参"><a href="#重载和-const-形参" class="headerlink" title="重载和 const 形参"></a>重载和 const 形参</h2><p>顶层 const 不影响传入函数的对象。一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开来：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-8.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-9.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-10.png" alt></p><h2 id="const-cast-和重载"><a href="#const-cast-和重载" class="headerlink" title="const_cast 和重载"></a>const_cast 和重载</h2><p>const_cast 在重载函数的情景中最有用。举个例子：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-11.png" alt></p><h2 id="调用重载的函数"><a href="#调用重载的函数" class="headerlink" title="调用重载的函数"></a>调用重载的函数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-12.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-13.png" alt></p><h1 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-14.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-15.png" alt></p><h1 id="特殊用途语言特征"><a href="#特殊用途语言特征" class="headerlink" title="特殊用途语言特征"></a>特殊用途语言特征</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-16.png" alt></p><h1 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-17.png" alt></p><h2 id="使用默认实参调用函数"><a href="#使用默认实参调用函数" class="headerlink" title="使用默认实参调用函数"></a>使用默认实参调用函数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-18.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-19.png" alt></p><h2 id="默认实参声明"><a href="#默认实参声明" class="headerlink" title="默认实参声明"></a>默认实参声明</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-20.png" alt></p><h2 id="默认实参初始值"><a href="#默认实参初始值" class="headerlink" title="默认实参初始值"></a>默认实参初始值</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-21.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-22.png" alt></p><h1 id="内联函数和-constexpr-函数"><a href="#内联函数和-constexpr-函数" class="headerlink" title="内联函数和 constexpr 函数"></a>内联函数和 constexpr 函数</h1><p>之前我们编写了一个小函数，它的功能是比较两个 string 形参的长度并返回长度较小的 string 的引用。把这种规模较小的操作定义成函数有很多好处，主要包括：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-23.png" alt></p><h2 id="内联函数可避免函数调用对开销"><a href="#内联函数可避免函数调用对开销" class="headerlink" title="内联函数可避免函数调用对开销"></a>内联函数可避免函数调用对开销</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-24.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-25.png" alt></p><h2 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a>constexpr 函数</h2><p><strong>constexpr 函数（constexpr function）</strong>是指能用于常量表达式的函数。定义 constexpr 函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条 return 语句：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-26.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-27.png" alt></p><h2 id="把内联函数和-constexpr-函数放在头文件内"><a href="#把内联函数和-constexpr-函数放在头文件内" class="headerlink" title="把内联函数和 constexpr 函数放在头文件内"></a>把内联函数和 constexpr 函数放在头文件内</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-28.png" alt></p><h1 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-29.png" alt></p><h2 id="assert-预处理宏"><a href="#assert-预处理宏" class="headerlink" title="assert 预处理宏"></a>assert 预处理宏</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-30.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-31.png" alt></p><h2 id="NDEBUG-预处理变量"><a href="#NDEBUG-预处理变量" class="headerlink" title="NDEBUG 预处理变量"></a>NDEBUG 预处理变量</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-32.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-33.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-34.png" alt></p><h1 id="定义模版"><a href="#定义模版" class="headerlink" title="定义模版"></a>定义模版</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-35.png" alt></p><h1 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-36.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-37.png" alt></p><h2 id="实例化函数模版"><a href="#实例化函数模版" class="headerlink" title="实例化函数模版"></a>实例化函数模版</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-38.png" alt></p><h2 id="模版类型参数"><a href="#模版类型参数" class="headerlink" title="模版类型参数"></a>模版类型参数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-39.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-40.png" alt></p><h2 id="非类型模版参数"><a href="#非类型模版参数" class="headerlink" title="非类型模版参数"></a>非类型模版参数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-41.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-42.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-43.png" alt></p><h2 id="inline-和-constexpr-的函数模版"><a href="#inline-和-constexpr-的函数模版" class="headerlink" title="inline 和 constexpr 的函数模版"></a>inline 和 constexpr 的函数模版</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-44.png" alt></p><h2 id="编写类型无关的代码"><a href="#编写类型无关的代码" class="headerlink" title="编写类型无关的代码"></a>编写类型无关的代码</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-45.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-46.png" alt></p><h2 id="模版编译"><a href="#模版编译" class="headerlink" title="模版编译"></a>模版编译</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-47.png" alt></p><h2 id="大多数编译错误在实例化期间报告"><a href="#大多数编译错误在实例化期间报告" class="headerlink" title="大多数编译错误在实例化期间报告"></a>大多数编译错误在实例化期间报告</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-48.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fifth-week-49.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p><p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Primer第四周的笔记</title>
      <link href="/about-cpp/2019/the-fourth-week-for-C++.html"/>
      <url>/about-cpp/2019/the-fourth-week-for-C++.html</url>
      
        <content type="html"><![CDATA[<h1 id="命名空间的-using-声明"><a href="#命名空间的-using-声明" class="headerlink" title="命名空间的 using 声明"></a>命名空间的 using 声明</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-1.jpg" alt></p><p>这是基于C++ Primer的第四周笔记，主要内容为C++的字符和字符串的标准模版库。包括命名空间的声明，标准库类型的字符串，处理字符串对象中的字符和额外的字符串操作。详细请见C++ Primer的3.1节至3.2节和9.5节。</p><a id="more"></a><p>目前为止，我们用到的库函数基本上都属于命名空间的 std，而程序也显式地将这一点标示了出来。例如，std::cin 表示从标准输入中读取内容。此处使用作用域操作符（::）的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。因此，std::cin 的意思就是要使用命名空间 std 中的名字 cin。</p><p>上面的方法显得比较繁琐，然而幸运的是，通过更简单的途径也能使用到命名空间中的成员。也就是使用 <strong>using 声明（using declaration）</strong>。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-2.png" alt></p><h2 id="每个名字都需要独立的-using-声明"><a href="#每个名字都需要独立的-using-声明" class="headerlink" title="每个名字都需要独立的 using 声明"></a>每个名字都需要独立的 using 声明</h2><p>按照规定，每个 using 声明引入命名空间中的一个成员。例如，可以把要用到的标准库中的名字都以 using 声明的形式表示出来，重写的程序如下：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-3.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-4.png" alt></p><h2 id="头文件不应包含-using-声明"><a href="#头文件不应包含-using-声明" class="headerlink" title="头文件不应包含 using 声明"></a>头文件不应包含 using 声明</h2><p>位于头文件的代码一般来说不应该使用 using 声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个 using 声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p><h1 id="标准库类型-string"><a href="#标准库类型-string" class="headerlink" title="标准库类型 string"></a>标准库类型 string</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-5.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-6.png" alt></p><h1 id="定义和初始化-string-对象"><a href="#定义和初始化-string-对象" class="headerlink" title="定义和初始化 string 对象"></a>定义和初始化 string 对象</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-7.png" alt></p><p>可以通过默认的方式初始化一个 string 对象，这样就会得到一个空的 string，也就是说，该 string 对象中没有任何字符。如果提供了一个字符串字面值，则该字面值中除了最后那个空字符外其他所有的字符都被拷贝到新创建的 string 对象中去。如果提供的是一个数字和一个字符，则 string 对象的内容是给定字符连续重复若干次后得到的序列。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-8.png" alt></p><h2 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h2><p>C++语言有几种不同的初始化方式，通过 string 我们可以清晰地看到在这些初始化方式之间到底有什么区别和联系。如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化（copy initialization）</strong>，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是<strong>直接初始化（direct initialization）</strong>。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-9.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-10.png" alt></p><h1 id="string-对象上的操作"><a href="#string-对象上的操作" class="headerlink" title="string 对象上的操作"></a>string 对象上的操作</h1><p>一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，也能定义 <strong>&lt;&lt; +</strong> 等各种运算符在该类对象上的新含义。下表列举了 string 的大多数操作。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-11.png" alt></p><h2 id="读写-string-对象"><a href="#读写-string-对象" class="headerlink" title="读写 string 对象"></a>读写 string 对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-12.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-13.png" alt></p><h2 id="读取未知数量的-string-对象"><a href="#读取未知数量的-string-对象" class="headerlink" title="读取未知数量的 string 对象"></a>读取未知数量的 string 对象</h2><p>下面编写一个程序用于读取数量未知的 string 对象：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-14.png" alt></p><h2 id="使用-getline-读取一整行"><a href="#使用-getline-读取一整行" class="headerlink" title="使用 getline 读取一整行"></a>使用 getline 读取一整行</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-15.png" alt></p><p>和输入运算符一样，getline 也会返回它的流参数。因此既然输入运算符能作为判断条件，我们也能用 getline 的结果作为条件。例如，可以通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-16.png" alt></p><h2 id="string-的-empty-和-size-操作"><a href="#string-的-empty-和-size-操作" class="headerlink" title="string 的 empty 和 size 操作"></a>string 的 empty 和 size 操作</h2><p>顾名思义，<strong>empty</strong> 函数根据 string 对象是否为空返回一个对应的布尔值。empty 是 string 的一个成员函数。调用该函数的方法很简单，只要使用点操作符指明是哪个对象执行了 empty 函数就可以了。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-17.png" alt></p><h2 id="string-size-type-类型"><a href="#string-size-type-类型" class="headerlink" title="string::size_type 类型"></a>string::size_type 类型</h2><p>对于 size 函数来说，返回一个 int 或者返回一个 unsigned 似乎都是合情合理的。但其实 size 函数返回的是一个 string::size_type 类型的值，下面就对这种新的类型稍作解释。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-18.png" alt></p><p>尽管我们不太清楚 string::size_type 类型的细节，但是有一点是肯定的：它是一个无符号类型的值，而且能足够存放下任何 string 对象的大小。所有用于存放 string 类的 size 函数返回值的变量，都应该是 string::size_type 类型的。</p><p>过去，string::size_type 这种类型有点神秘，不太容易理解和使用。在 C++11 新标准中，允许编译器通过 auto 或者 decltype 来推断变量的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = line.size();  <span class="comment">// len 的类型是 string::size_type</span></span><br></pre></td></tr></table></figure><p>由于 size 函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设 n 是一个具有负值的 int，则表达式 s.size() &lt; n 的判断结果几乎肯定是 true。这是因为负值 n 会自动地转换成一个比较大的无符号值。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-19.png" alt></p><h2 id="比较-string-对象"><a href="#比较-string-对象" class="headerlink" title="比较 string 对象"></a>比较 string 对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-20.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-21.png" alt></p><h2 id="为-string-对象赋值"><a href="#为-string-对象赋值" class="headerlink" title="为 string 对象赋值"></a>为 string 对象赋值</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-22.png" alt></p><h2 id="两个-string-对象相加"><a href="#两个-string-对象相加" class="headerlink" title="两个 string 对象相加"></a>两个 string 对象相加</h2><p>两个 string 对象相加得到一个新的 string 对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。也就是说，对 string 对象使用加法运算符（+）的结果是一个新的 string 对象，它所包含的字符由两部分组成：前半部分是加号左侧 string 对象所包含的字符，后半部分是加号右侧 string 对象所包含的字符。另外，复合赋值运算符（+=）负责把右侧 string 对象的内容追加到左侧 string 对象的后面：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-23.png" alt></p><h2 id="字面值和-string-对象相加"><a href="#字面值和-string-对象相加" class="headerlink" title="字面值和 string 对象相加"></a>字面值和 string 对象相加</h2><p>即使一种类型并非所需，我们也可以使用它，不过前提是该种类型可以自动转换成所需的类型。因为标准库允许把字符字面值和字符串字面值转换成 string 对象，所以在需要 string 对象的地方就可以使用这两种字面值来代替。利用这一点将之前的程序改写为如下形式：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-24.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-25.png" alt></p><p>s4 和 s5 初始化时只用到了一个加法运算符，因此很容易判断是否合法。s6 的初始化形式之前没有出现过，但其实它的工作机理和连续输入连续输出是一样的，可以用如下的形式分组：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-26.png" alt></p><h1 id="处理-string-对象中的字符"><a href="#处理-string-对象中的字符" class="headerlink" title="处理 string 对象中的字符"></a>处理 string 对象中的字符</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-27.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-28.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-29.png" alt></p><h2 id="处理每个字符（使用基于范围的-for-语句）"><a href="#处理每个字符（使用基于范围的-for-语句）" class="headerlink" title="处理每个字符（使用基于范围的 for 语句）"></a>处理每个字符（使用基于范围的 for 语句）</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-30.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-31.png" alt></p><p>for 循环把变量 c 和 str 联系了起来，其中我们定义循环控制变量的方式与定义任意一个普通变量是一样的。此例子，通过使用 auto 关键字让编译器来决定变量 c 的类型，这里 c 的类型是 char。每次迭代，str 的下一个字符被拷贝给 c，因此该循环可以读作“对于字符串 str 中的每个字符 c，执行某某操作。”此例中的“某某操作”即输出一个字符，然后换行。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-32.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello World!!!"</span>)</span></span>;</span><br><span class="line"><span class="comment">// punct_cnt 的类型和 s.size() 的返回类型一样</span></span><br><span class="line"><span class="keyword">decltype</span> (s.size()) punct_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 统计 s 中标点符号的数量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)        <span class="comment">// 对于 s 中的每个字符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))     <span class="comment">// 如果该字符是标点符号</span></span><br><span class="line">        ++punct_cnt;    <span class="comment">// 将标点符号的计数值加一</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; punct_cnt &lt;&lt; <span class="string">" punctuation characters in "</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-33.png" alt></p><p>这里我们使用 decltype 关键字声明计数变量 punct_cnt，它的类型是 s.size() 函数返回值的类型，也就是 string::size_type。使用范围 for 语句处理 string 对象中的每个字符并检查其是否是标点符号。如果是，使用递增运算符给计数变量加一。最后，待范围 for 语句结束后输出统计结果。</p><h2 id="使用范围-for-语句改变字符串中的字符"><a href="#使用范围-for-语句改变字符串中的字符" class="headerlink" title="使用范围 for 语句改变字符串中的字符"></a>使用范围 for 语句改变字符串中的字符</h2><p>如果想要改变 string 对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-34.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-35.png" alt></p><h2 id="只处理一部分字符"><a href="#只处理一部分字符" class="headerlink" title="只处理一部分字符"></a>只处理一部分字符</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-36.png" alt></p><p>要想访问 string 对象中的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。</p><p><strong>下标运算符 [ ] </strong>接收的输入参数是 string::size_type 类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-37.png" alt></p><p>下标的值称作“下标”或<strong>“索引”</strong>，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由 string::size_type 表达的无符号类型。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-38.png" alt></p><p>只要字符串不是常量，就能为下标运算符返回的字符赋新值。例如，下面的程序将字符串的首字符改成了大写形式：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-39.png" alt></p><h2 id="使用下标执行迭代"><a href="#使用下标执行迭代" class="headerlink" title="使用下标执行迭代"></a>使用下标执行迭代</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-40.png" alt></p><h2 id="使用下标执行随机访问"><a href="#使用下标执行随机访问" class="headerlink" title="使用下标执行随机访问"></a>使用下标执行随机访问</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-41.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-42.png" alt></p><p>上述程序的执行过程是这样的：首先初始化变量 hexdigits 令其存放从 0 到 F 的十六进制数字，注意我们把 hexdigits 声明成了常量，这是因为在后面的程序中不打算再改变它的值。在循环内部使用输入值 n 作为 hexdigits 的下标，hexdigits [n] 的值就是 hexdigits 内位置 n 处的字符。例如，如果 n 是 15，则结果是 F，如果 n 是 12，则结果是 C，以此类推。把得到的十六进制数字添加到 result 内，最后一并输出。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-43.png" alt></p><h1 id="额外的-string-操作"><a href="#额外的-string-操作" class="headerlink" title="额外的 string 操作"></a>额外的 string 操作</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-44.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-45.png" alt></p><h1 id="构造-string-的其他方法"><a href="#构造-string-的其他方法" class="headerlink" title="构造 string 的其他方法"></a>构造 string 的其他方法</h1><p>除了已经介绍过的构造函数，以及与其他顺序容器相同的构造函数外，string 类型还支持另外三个构造函数，如下表所示。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-46.png" alt></p><p>当从一个 string 拷贝字符时，我们可以提供一个可选的开始位置和一个计数值。开始位置必须小于或者等于给定的 string 的大小。如果位置大于 size，则构造函数抛出一个 out_of_range 异常。如果我们传递了一个计数值，则从给定位置开始拷贝这么多个字符。不管我们要求拷贝多少个字符，标准库最多拷贝到 string 结尾，不会更多。</p><h2 id="substr-操作"><a href="#substr-操作" class="headerlink" title="substr 操作"></a>substr 操作</h2><p>substr 操作返回一个 string，它是原始 string 的一部分或者全部的拷贝。可以传递给 substr 一个可选的开始位置和计数值：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-47.png" alt></p><p>如果开始位置超过了 string 的大小，则 substr 函数抛出一个 out_of_range 异常。如果开始位置加上计数值大于 string 的大小，则 substr 会调整计数值，只会拷贝到 string 的末尾。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-48.png" alt></p><h1 id="改变-string-的其他方法"><a href="#改变-string-的其他方法" class="headerlink" title="改变 string 的其他方法"></a>改变 string 的其他方法</h1><p>string 类型支持顺序容器的赋值运算符以及 assign insert 和 erase 操作。除此之外，它还定义了额外的 insert 和 erase 版本。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-49.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-50.png" alt></p><h2 id="append-和-replace-函数"><a href="#append-和-replace-函数" class="headerlink" title="append 和 replace 函数"></a>append 和 replace 函数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-51.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-52.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-53.png" alt></p><h2 id="改变-string-的多种重载函数"><a href="#改变-string-的多种重载函数" class="headerlink" title="改变 string 的多种重载函数"></a>改变 string 的多种重载函数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-54.png" alt></p><h1 id="string-搜索操作"><a href="#string-搜索操作" class="headerlink" title="string 搜索操作"></a>string 搜索操作</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-55.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-56.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-57.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-58.png" alt></p><h2 id="指定在哪里开始搜索"><a href="#指定在哪里开始搜索" class="headerlink" title="指定在哪里开始搜索"></a>指定在哪里开始搜索</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-59.png" alt></p><h2 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-60.png" alt></p><h1 id="compare-函数"><a href="#compare-函数" class="headerlink" title="compare 函数"></a>compare 函数</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-61.png" alt></p><h1 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-62.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-63.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201902/fourth-week-64.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p><p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Primer第三周的笔记-2</title>
      <link href="/about-cpp/2019/the-third-week-for-C++-2.html"/>
      <url>/about-cpp/2019/the-third-week-for-C++-2.html</url>
      
        <content type="html"><![CDATA[<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-2.jpg" alt></p><p>这是基于C++ Primer的第三周笔记，主要内容为C++的函数和更多的程序类型。包括函数基础，参数传递，返回类型，复合类型，处理类型，引用和指针。详细请见C++ Primer的6.1节至6.3节，2.3节至2.5节。</p><a id="more"></a><p><strong>复合类型（compound type）</strong>是指基于其他类型定义的类型。C++语言有几种复合类型，这里将介绍两种：引用和指针。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-35.png" alt></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><strong>引用（reference）</strong>为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成 <strong>&amp;d</strong> 的形式来定义引用类型，其中 <strong>d</strong> 是声明的变量名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refval = ival;  <span class="comment">// refval 指向 ival（是 ival 的另一个名字）</span></span><br><span class="line"><span class="keyword">int</span> &amp;refval2;        <span class="comment">// 报错: 引用必须被初始化</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-36.png" alt></p><h2 id="引用即别名"><a href="#引用即别名" class="headerlink" title="引用即别名"></a>引用即别名</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-37.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">refval = <span class="number">2</span>;        <span class="comment">// 把 2 赋给 refval 指向的对象, 此处即是赋给了 ival</span></span><br><span class="line"><span class="keyword">int</span> ii = refval;   <span class="comment">// 与 ii = ival 执行结果一样</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-38.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确: refval3 绑定到了那个与 refval 绑定的对象上, 这里就是绑定到 ival 上</span></span><br><span class="line"><span class="keyword">int</span> &amp;refval3 = refval;</span><br><span class="line"><span class="comment">// 利用与 refval 绑定的对象的值初始值变量 i</span></span><br><span class="line"><span class="keyword">int</span> i = refval;</span><br></pre></td></tr></table></figure><p>因为引用本身不是一个对象，所以不能定义引用的引用。</p><h2 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a>引用的定义</h2><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号 <strong>&amp;</strong> 开头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">1024</span>, i2 = <span class="number">2048</span>;  <span class="comment">// i1 和 i2 都是 int</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = i1, r2 = i2;      <span class="comment">// r 是一个引用, 与 i1 绑定到一起, r2 是 int</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">1024</span>, &amp;ri = i3;  <span class="comment">// i3 是 int, ri 是一个引用, 与 i3 绑定到一起</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = i3, &amp;r4 = i2;   <span class="comment">// r3 和 r4 都是引用</span></span><br></pre></td></tr></table></figure><p>所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或者某个表达式的计算结果绑定在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;refval4 = <span class="number">10</span>;    <span class="comment">// 错误: 引用类型的初始值必须是一个对象</span></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refval5 = dval;  <span class="comment">// 错误: 此处引用类型的初始值必须是 int 型对象</span></span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-39.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip1, *ip2;      <span class="comment">// ip1 和 ip2 都是指向 int 型对象的指针</span></span><br><span class="line"><span class="keyword">double</span> dp, *dp2;     <span class="comment">// dp2 是指向 double 型对象的指针, dp 是 double 型对象</span></span><br></pre></td></tr></table></figure><h2 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h2><p>指针存放某个对象的地址，要想获取该地址，需要使用<strong>取地址符（操作符 &amp; ）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;     <span class="comment">// p 存放变量 ival 的地址, 或者说 p 是指向变量 ival 的指针</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-40.png" alt></p><p>所有指针的类型都要和它所指向的对象严格匹配：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-41.png" alt></p><h2 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h2><p>指针的值（即地址）应属下列 4 种状态之一：</p><ol><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置。</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况之外的其他值。</li></ol><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-42.png" alt></p><h2 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h2><p>如果指针指向了一个对象，则允许使用<strong>解引用符（操作符 * ）</strong>来访问该对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-43.png" alt></p><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p><strong>空指针（null pointer）</strong>不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-44.png" alt></p><h2 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-45.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-46.png" alt></p><h2 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h2><p>只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则类似，如果指针的值是 0，条件取 false：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-47.png" alt></p><h2 id="viod-指针"><a href="#viod-指针" class="headerlink" title="viod* 指针"></a>viod* 指针</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-48.png" alt></p><p>概括来说，以 <strong>void*</strong> 的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。</p><h1 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-49.png" alt></p><h2 id="定义多个变量"><a href="#定义多个变量" class="headerlink" title="定义多个变量"></a>定义多个变量</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-50.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-51.png" alt></p><h2 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-52.png" alt></p><h2 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-53.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-54.png" alt></p><h1 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-55.png" alt></p><h2 id="初始化和-const"><a href="#初始化和-const" class="headerlink" title="初始化和 const"></a>初始化和 const</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-56.png" alt></p><h2 id="默认情况下，const-对象仅在文件内有效"><a href="#默认情况下，const-对象仅在文件内有效" class="headerlink" title="默认情况下，const 对象仅在文件内有效"></a>默认情况下，const 对象仅在文件内有效</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-57.png" alt></p><h1 id="const-的引用"><a href="#const-的引用" class="headerlink" title="const 的引用"></a>const 的引用</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-58.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-59.png" alt></p><h2 id="对-const-的引用可能引用一个并非-const-的对象"><a href="#对-const-的引用可能引用一个并非-const-的对象" class="headerlink" title="对 const 的引用可能引用一个并非 const 的对象"></a>对 const 的引用可能引用一个并非 const 的对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-60.png" alt></p><h1 id="指针和-const"><a href="#指针和-const" class="headerlink" title="指针和 const"></a>指针和 const</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-61.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-62.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-63.png" alt></p><h2 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-64.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-65.png" alt></p><h1 id="顶层-const"><a href="#顶层-const" class="headerlink" title="顶层 const"></a>顶层 const</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-66.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-67.png" alt></p><h1 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-68.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-69.png" alt></p><h2 id="constexpr-变量"><a href="#constexpr-变量" class="headerlink" title="constexpr 变量"></a>constexpr 变量</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-70.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-71.png" alt></p><h2 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-72.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-73.png" alt></p><h2 id="指针和-constexpr"><a href="#指针和-constexpr" class="headerlink" title="指针和 constexpr"></a>指针和 constexpr</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-74.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-75.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-76.png" alt></p><h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-77.png" alt></p><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-78.png" alt></p><p>其中，关键字 typedef 作为声明语句中的基本数据类型的一部分出现。含有 typedef 的声明语句定义的不再是变量而是类型别名。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-79.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-80.png" alt></p><h2 id="指针，常量和类型别名"><a href="#指针，常量和类型别名" class="headerlink" title="指针，常量和类型别名"></a>指针，常量和类型别名</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-81.png" alt></p><h1 id="auto-类型说明符"><a href="#auto-类型说明符" class="headerlink" title="auto 类型说明符"></a>auto 类型说明符</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-82-1.png" alt></p><p>此处编译器将根据 val1 和 val2 相加的结果来推断 item 的类型。如果 val1 和 val2 这两个变量的类型是 double，则 item 的类型就是 double，以此类推。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-82-2.png" alt></p><h2 id="复合类型，常量和-auto"><a href="#复合类型，常量和-auto" class="headerlink" title="复合类型，常量和 auto"></a>复合类型，常量和 auto</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-83.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-84.png" alt></p><p>其次，auto 一般会忽略掉顶层 const，同时底层 const 则会保留下来，比如当初始值是一个指向常量的指针时：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-85.png" alt></p><h1 id="decltype-类型指示符"><a href="#decltype-类型指示符" class="headerlink" title="decltype 类型指示符"></a>decltype 类型指示符</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-86.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-87.png" alt></p><h2 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h2><p>如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。有些表达式将向 decltype 返回一个引用类型。一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-88.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p><p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Primer第三周的笔记-1</title>
      <link href="/about-cpp/2019/the-third-week-for-C++-1.html"/>
      <url>/about-cpp/2019/the-third-week-for-C++-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-2.jpg" alt></p><p>这是基于C++ Primer的第三周笔记，主要内容为C++的函数和更多的程序类型。包括函数基础，参数传递，返回类型，复合类型，处理类型，引用和指针。详细请见C++ Primer的6.1节至6.3节，2.3节至2.5节。</p><a id="more"></a><p>函数是一个命名的代码块，通过调用函数执行相应代码。函数可以有 0 个或多个参数，而且（通常）会产生一个结果。可以重载函数，也就是说，同一个名字可以对应几个不同的函数。</p><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><p>一个典型的<strong>函数（function）</strong>定义包括以下部分：<strong>返回类型（return type）</strong>，函数名字，由 0 个或多个<strong>形参（parameter）</strong>组成的列表以及函数体。其中，形参以逗号隔开，形参的列表对于一对圆括号之内。函数执行的操作在语句块中说明，该语句块称为<strong>函数体（function body）</strong>。</p><p>我们通过<strong>调用运算符（call operator）</strong>来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针：圆括号之内是一个用逗号隔开的<strong>实参（argument）</strong>列表，用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。</p><h2 id="编写函数"><a href="#编写函数" class="headerlink" title="编写函数"></a>编写函数</h2><p>编写一个求数的阶乘的程序。n 的阶乘是从 1 到 n 所有数字的乘积。</p><p>程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;          <span class="comment">// 局部变量，用于保存计算结果</span></span><br><span class="line">    <span class="keyword">while</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">        ret *= val --;    <span class="comment">// 把 ret 和 val 的乘积赋给 ret, 然后 val 减一</span></span><br><span class="line">    <span class="keyword">return</span> ret;           <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的名字是 fact，作用于一个整型参数，返回一个整型值。在 while 循环内部，在每次迭代时用后置递减运算符将 val 的值减一。return 语句负责结束 fact 并返回 ret 的值。</p><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>要调用 fact 函数，必须提供一个整数值，调用得到的结果也是一个整数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = fact(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5! is "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，<strong>主调函数（calling function）</strong>的执行被暂时中断，<strong>被调函数（called function）</strong>开始执行。</p><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>实参是形参的初始值。尽管实参于形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任何可行的顺序对实参求值。</p><p>实参的类型必须与对应的形参类型匹配。函数有几个形参，就必须提供相同数量的实参。因为函数的调用规定实参数量应与形参数量一致，所以形参一定会被初始化。</p><h2 id="函数的形参列表"><a href="#函数的形参列表" class="headerlink" title="函数的形参列表"></a>函数的形参列表</h2><p>函数的形参列表可以为空，但是不能省略。想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。也可以使用关键字 void 表示函数没有形参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125;        <span class="comment">// 隐式的定义空形参列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;    <span class="comment">// 显式的定义空形参列表</span></span><br></pre></td></tr></table></figure><p>任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-3.png" alt></p><h2 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h2><p>大多数类型都能用作函数的返回类型。一种特殊的返回类型是 void，它表示函数不返回任何值。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。</p><h1 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h1><p>在C++语言中，名字有作用域，对象有<strong>生命周期（lifetime）</strong>。</p><ul><li>名字的作用域是程序文本的一部分，名字在其中可见。</li><li>对象的生命周期是程序执行过程中该对象存在的一段时间。</li></ul><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-4.png" alt></p><h2 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-5.png" alt></p><h2 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-6.png" alt></p><p>如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为 0 。</p><h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><p>和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。</p><p>函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号代替即可。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-7.png" alt></p><h2 id="在头文件中进行函数声明"><a href="#在头文件中进行函数声明" class="headerlink" title="在头文件中进行函数声明"></a>在头文件中进行函数声明</h2><p>我们建议变量在头文件中声明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。</p><p>看起来把函数的声明直接放在使用该函数的源文件中是合法的，也比较容易被人接受；但是这么做可能会很繁琐而且容易出错。相反，如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。</p><p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-8.png" alt></p><h1 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h1><p>随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。为了允许编写程序时按照逻辑关系将其划分开来，C++语言支持所谓的<strong>分离式编译（separate compilation）</strong>。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。</p><h2 id="编译和链接多个源文件"><a href="#编译和链接多个源文件" class="headerlink" title="编译和链接多个源文件"></a>编译和链接多个源文件</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-9.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-10.png" alt></p><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>如前所述，每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-11.png" alt></p><p>和其他变量一样，形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-12.png" alt></p><h2 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h2><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;   <span class="comment">// int 类型的初始变量</span></span><br><span class="line"><span class="keyword">int</span> i = n;   <span class="comment">// i 是 n 的值的副本</span></span><br><span class="line">i = <span class="number">42</span>;      <span class="comment">// i 的值改变，n 的值不变</span></span><br></pre></td></tr></table></figure><p>传值参数的机理完全一样，函数对形参做的所有操作都不会影响实参。</p><h3 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h3><p>指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;n, *q = &amp;i;  <span class="comment">// p 指向 n; q 指向 i</span></span><br><span class="line">*p = <span class="number">42</span>;               <span class="comment">// n 的值改变; p 不变</span></span><br><span class="line">p = q                  <span class="comment">// p 现在指向了 i; 但是 i 和 n 的值都不变</span></span><br></pre></td></tr></table></figure><p>指针形参的行为与之类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数接受一个指针, 然后将指针所指的值置为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *ip)</span> </span>&#123;</span><br><span class="line">    *ip = <span class="number">0</span>;  <span class="comment">// 改变指针 ip 所指对象的值</span></span><br><span class="line">    ip = <span class="number">0</span>;   <span class="comment">// 只改变了 ip 的局部拷贝, 实参未被改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 reset 函数之后，实参所指的对象被置为 0，但是实参本身并没有改变：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">reset(&amp;i);          <span class="comment">// 改变 i 的值而非 i 的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-13.png" alt></p><h2 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h2><p>回忆过去所学的知识，我们知道对于引用的操作实际上是作用在引用所引的对象上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = n;  <span class="comment">// r 绑定了 n（即 r 是 n 的另外一个名字）</span></span><br><span class="line">r = <span class="number">42</span>;      <span class="comment">// 现在 n 的值是 42</span></span><br><span class="line">r = i;       <span class="comment">// 现在 n 的值和 i 相同</span></span><br><span class="line">i = r;       <span class="comment">// i 的值和 n 相同</span></span><br></pre></td></tr></table></figure><p>引用形参的行为与之类似。通过使用引用形参，允许函数改变一个或多个实参的值。</p><p>举个例子，改写上一节的 reset 程序，使其接受的参数是引用类型而非指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数接受一个 int 对象的引用, 然后将对象的值置为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;i)</span> </span>&#123;  <span class="comment">// i 是传给 reset 函数的对象的另一个名字</span></span><br><span class="line">    i = <span class="number">0</span>;            <span class="comment">// 改变了 i 所引对象的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-14.png" alt></p><h3 id="使用引用避免拷贝"><a href="#使用引用避免拷贝" class="headerlink" title="使用引用避免拷贝"></a>使用引用避免拷贝</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-15.png" alt></p><p>举个例子，准备编写一个函数比较两个 string 对象的长度。因为 string 对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。又因为比较长度无须改变 string 对象的内容，所以把形参定义成对常量的引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较两个 string 对象的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数无须修改引用形参的值时最好使用常量引用。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-16.png" alt></p><h3 id="使用引用形参返回额外信息"><a href="#使用引用形参返回额外信息" class="headerlink" title="使用引用形参返回额外信息"></a>使用引用形参返回额外信息</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-17.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-18.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 s 中 c 第一次出现的位置索引</span></span><br><span class="line"><span class="comment">// 引用形参 occurs 负责统计 c 出现的总次数</span></span><br><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">find_char</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">char</span> c, <span class="built_in">string</span>::size_type &amp;occurs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = s.size();  <span class="comment">// 第一次出现的位置（如果有的话）</span></span><br><span class="line">    occurs = <span class="number">0</span>;           <span class="comment">// 设置表示出现次数的形参的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">decltype</span>(ret) i = <span class="number">0</span>; i != s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret == s.size())</span><br><span class="line">                ret = i;  <span class="comment">// 记录 c 第一次出现的位置</span></span><br><span class="line">            ++occurs;     <span class="comment">// 将出现的次数加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;           <span class="comment">// 出现次数通过 occurs 隐式地返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用 find_char 函数时，必须传入三个实参：作为查找范围的一个 string 对象，要找的字符以及一个用于保存字符出现次数的 size_type 对象。假设 s 是一个 string 对象，ctr 是一个 size_type 对象，则我们通过如下形式调用 find_char 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> index = find_char(s, <span class="string">'o'</span>, ctr);</span><br></pre></td></tr></table></figure><p>调用完成后，如果 string 对象中确实存在 o，那么 ctr 的值就是 o 出现的次数，index 指向 o 第一次出现的位置；否则如果 string 对象中没有 o，index 等于 s.size() 而 ctr 等于 0 。</p><h2 id="const-形参和实参"><a href="#const-形参和实参" class="headerlink" title="const 形参和实参"></a>const 形参和实参</h2><p>当形参是 const 时，必须要注意关于顶层 const 的讨论。顶层 const 作用于对象本身：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;  <span class="comment">// 不能改变 ci, const 是顶层的</span></span><br><span class="line"><span class="keyword">int</span> i = ci;         <span class="comment">// 正确: 当拷贝 ci 时, 忽略了它的顶层 const</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;  <span class="comment">// const 是顶层的, 不能给 p 赋值</span></span><br><span class="line">*p = <span class="number">0</span>;             <span class="comment">// 正确: 通过 p 改变对象的内容是允许的, 现在 i 变成了 0</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-19.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* fcn 能够读取 i, 但是不能向 i 写值 */</span> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-20.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* fcn 能够读取 i, 但是不能向 i 写值 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;      <span class="comment">// 错误: 重复定义了 fcn(int)</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-21.png" alt></p><h3 id="指针或引用形参与-const"><a href="#指针或引用形参与-const" class="headerlink" title="指针或引用形参与 const"></a>指针或引用形参与 const</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-22.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cp = &amp;i;  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = i;    <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">int</span> *p = cp;         <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = r;         <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = <span class="number">42</span>;        <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>将同样的初始化规则应用到参数传递上可得如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="built_in">string</span>::size_type ctr = <span class="number">0</span>;</span><br><span class="line">reset(&amp;i);        <span class="comment">// 调用形参类型是 int* 的 reset 函数</span></span><br><span class="line">reset(&amp;ci);       <span class="comment">// 错误</span></span><br><span class="line">reset(i);         <span class="comment">// 调用形参类型是 int&amp; 的 reset 函数</span></span><br><span class="line">reset(ci);        <span class="comment">// 错误</span></span><br><span class="line">reset(<span class="number">42</span>);        <span class="comment">// 错误</span></span><br><span class="line">reset(ctr);       <span class="comment">// 错误</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">find_char(<span class="string">"Hello World!"</span>, <span class="string">'o'</span>, ctr);</span><br></pre></td></tr></table></figure><h3 id="尽量使用常量引用"><a href="#尽量使用常量引用" class="headerlink" title="尽量使用常量引用"></a>尽量使用常量引用</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-23.png" alt></p><h2 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-24.png" alt></p><h2 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="headerlink" title="main: 处理命令行选项"></a>main: 处理命令行选项</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-25.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-26.png" alt></p><h2 id="含有可变形参的参数"><a href="#含有可变形参的参数" class="headerlink" title="含有可变形参的参数"></a>含有可变形参的参数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-27.png" alt></p><h1 id="返回类型和-return-语句"><a href="#返回类型和-return-语句" class="headerlink" title="返回类型和 return 语句"></a>返回类型和 return 语句</h1><p>return 语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。</p><p>return 语句有两种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure><h2 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-28.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-29.png" alt></p><h2 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h2><p>return 语句的第二种形式提供了函数的结果。只要函数的返回类型不是 void，则该函数内的每条 return 语句必须返回一个值。return 语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-30.png" alt></p><h3 id="值是如何被返回的"><a href="#值是如何被返回的" class="headerlink" title="值是如何被返回的"></a>值是如何被返回的</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-31.png" alt></p><h3 id="不要返回局部对象的引用或指针"><a href="#不要返回局部对象的引用或指针" class="headerlink" title="不要返回局部对象的引用或指针"></a>不要返回局部对象的引用或指针</h3><p>函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。</p><p>返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。</p><h3 id="调用运算符"><a href="#调用运算符" class="headerlink" title="调用运算符"></a>调用运算符</h3><p>调用运算符也有优先级和结合律。调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。</p><h3 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h3><p>函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-32.png" alt></p><h3 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h3><p>C++11 新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p><h3 id="主函数-main-的返回值"><a href="#主函数-main-的返回值" class="headerlink" title="主函数 main 的返回值"></a>主函数 main 的返回值</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-33.png" alt></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/third-week-34.png" alt></p><h2 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h2><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p><p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Primer第二周的笔记</title>
      <link href="/about-cpp/2019/the-second-week-for-C++.html"/>
      <url>/about-cpp/2019/the-second-week-for-C++.html</url>
      
        <content type="html"><![CDATA[<h1 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-1.jpg" alt></p><p>这是基于C++ Primer的第二周笔记，主要内容为C++的控制语句。包括简单语句，条件语句，迭代语句和跳转语句。详细请见C++ Primer的5.1节至5.5节，跳过5.4.3节。</p><a id="more"></a><p>通常情况下，语句都是按顺序执行，但除非是最简单的程序，不然仅仅执行顺序语句对于程序是远远不够的。所以C++语言提供了一组<strong>控制流（flow-of-control）</strong>语句以支持复杂的语句。</p><p>一个表达式末尾加上分号就变成了<strong>表达式语句（expression statement）</strong>。其作用是执行表达式并丢弃求值结果。</p><h2 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h2><p>最简单的语句就是<strong>空语句（null statement）</strong>，只含有一个分号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;  <span class="comment">// 空语句</span></span><br></pre></td></tr></table></figure><p>空语句被用作于：<strong>语法上需要一条语句，但逻辑上不需要。</strong>一种常见的情况是，当循环的全部工作在条件部分就可以完成时，通常会用到空语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重复读如数据直至某次输入的值等于sought</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">    ;  <span class="comment">// 空语句</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-2.png" alt></p><h2 id="别漏写分号，也别多写分号"><a href="#别漏写分号，也别多写分号" class="headerlink" title="别漏写分号，也别多写分号"></a>别漏写分号，也别多写分号</h2><p>因为空语句是一条语句，可以用在任何地方。由于这个原因，很多看起来是非法的语句，往往都是空语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = v1 + v2;;  <span class="comment">// 正确：第二个分号表示一条多余的空语句</span></span><br></pre></td></tr></table></figure><p>一般来说空语句是无害的，但如果出现在 if 或者 while 之后，就会改变程序的初衷。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iter != svec.end()) ;  <span class="comment">// 循环空语句</span></span><br><span class="line">    ++iter;</span><br></pre></td></tr></table></figure><p><strong>多余的空语句并非总是无害的</strong></p><h2 id="复合语句-块"><a href="#复合语句-块" class="headerlink" title="复合语句 / 块"></a>复合语句 / 块</h2><p><strong>复合语句（compound statement）</strong>是指用花括号括起来的语句和声明的序列。复合语句也被叫做<strong>块（block）</strong>。在块中引入的名字只能在块中内访问。</p><p>如果在程序中：<strong>语法上需要一条语句，但逻辑上需要多条语句。</strong>则应该使用复合语句。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-3.png" alt></p><p>所谓空块，是指内部没有任何语句的一对花括号，空块作用等价于空语句。</p><h1 id="语句的作用域"><a href="#语句的作用域" class="headerlink" title="语句的作用域"></a>语句的作用域</h1><p>可以在 if，switch，while 和 for 语句的控制结构内定义变量。定义在控制结构内的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了。</p><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>C++语言提供了两种按条件执行的语句。一种是 if 语句，它根据条件决定控制流。另一种是 switch 语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。</p><h2 id="if-语句（if-statement）"><a href="#if-语句（if-statement）" class="headerlink" title="if 语句（if statement）"></a>if 语句（if statement）</h2><p><strong>作用：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。</strong></p><p>if 语句包含两种形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>其中 condition 必须使用圆括号括起来。condition 可以是一个表达式，也可以是一个初始化了的变量声明。但不管是表达式还是变量，其类型都必须能转化成布尔类型。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-4.png" alt></p><h3 id="使用-if-else-语句"><a href="#使用-if-else-语句" class="headerlink" title="使用 if else 语句"></a>使用 if else 语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; scores = &#123;<span class="string">"F"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"A++"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 grade 小于60 对应的字母是 F 否则计算其下标</span></span><br><span class="line"><span class="built_in">string</span> = letter;</span><br><span class="line"><span class="keyword">if</span> (grade &lt; <span class="number">60</span>)</span><br><span class="line">    letter = scores[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    letter = scores[(grade - <span class="number">50</span>) / <span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="嵌套-if-语句"><a href="#嵌套-if-语句" class="headerlink" title="嵌套 if 语句"></a>嵌套 if 语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (grade % <span class="number">10</span> &gt; <span class="number">7</span>)</span><br><span class="line">    letter += <span class="string">'+'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (grade % <span class="number">10</span> &lt; <span class="number">3</span>)</span><br><span class="line">    letter += <span class="string">'-'</span>;</span><br></pre></td></tr></table></figure><h3 id="注意使用花括号"><a href="#注意使用花括号" class="headerlink" title="注意使用花括号"></a>注意使用花括号</h3><p>有一种常见的错误：<strong>本来程序中有几条语句应该作为一个块来执行，但是我们忘了用花括号把这些语句包围。</strong>这会违背程序的初衷。</p><p>为了避免此类问题，有些代码风格要求在 if 或者 else 之后必须写上花括号（对 while 和 for 语句也有同样的要求）这么做的好处是可以避免代码混乱不清，以后修改代码时如果想添加别的语句，也可以很容易的找到正确的位置。</p><h3 id="垂悬-else"><a href="#垂悬-else" class="headerlink" title="垂悬 else"></a>垂悬 else</h3><p>当一个 if 语句嵌套在另一个 if 语句内部时，很可能 if 分支会多于 else 分支。事实上，这时候问题出现了：<strong>怎么知道某个给定的 else 是和哪个 if 匹配呢？</strong></p><p>这个问题通常称作<strong>悬垂 else（dangling else）</strong>，对于这个问题不同的语言有着不同的解决方式，对于C++而言，它规定 else 与离它最近的尚未匹配的 if 匹配，从而消除了程序的二义性。</p><h3 id="使用花括号控制执行路径"><a href="#使用花括号控制执行路径" class="headerlink" title="使用花括号控制执行路径"></a>使用花括号控制执行路径</h3><p>要想使 else 分支和外层的 if 语句匹配，可以在内层 if 语句的两端加上花括号，使其成为一个块。</p><h2 id="switch-语句（switch-statement）"><a href="#switch-语句（switch-statement）" class="headerlink" title="switch 语句（switch statement）"></a>switch 语句（switch statement）</h2><p>此语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。</p><p>举个例子，统计五个元音字母在一篇文章中出现的次数，程序逻辑应该是：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-5.jpg" alt></p><p>switch 语句首先对括号里的表达式求值，该表达式紧跟在关键词 switch 的后面，可以是一个初始化的变量声明。表达式的值转换成整数类型，然后与每个 case 标签的值比较。</p><p>如果表达式和某个 case 标签的值匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了 switch 的结尾或者遇到一条 break 语句为止。</p><p>如果 switch 语句的表达式和所有 case 都没有匹配上，将直接跳转到 switch 结构之后的第一条语句。</p><p>case 关键字和它对应的值一起被称为 <strong>case 标签（case label）</strong>。case 标签必须是整型常量表达式。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-6.png" alt></p><p>任何两个 case 标签的值不能相同，否则就会引发错误。另外，default 也是一种特殊的 case 标签。</p><h3 id="switch-内部的控制流"><a href="#switch-内部的控制流" class="headerlink" title="switch 内部的控制流"></a>switch 内部的控制流</h3><p>理解程序在 case 标签之间的执行流程非常重要。如果某个 case 标签匹配成功，将从该标签开始往后顺序执行所有 case 分支，除非程序显式的中断了这一过程，否则直到 switch 的结尾处才会停下。要想避免执行后续的 case 分支代码，我们必须显式的告诉编译器终止执行过程。</p><p>大多数情况下，在下一个 case 标签之前应该有一条 break 语句。</p><p>然而，也有一些时候默认的 switch 行为才是程序真正需要的。每个 case 标签只能对应一个值，但是有时候我们希望两个或者更多个值共享同一组操作。此时，我们就故意省略 break 语句，使得程序能够连续执行若干个 case 标签。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-7.png" alt></p><p>C++程序的形式比较自由，所以 case 标签之后不一定非得换行。把几个 case 标签写在一行里，强调这些 case 代表的是某个范围内的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'i'</span>: <span class="keyword">case</span> <span class="string">'o'</span>: <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-8.png" alt></p><h3 id="漏写-break-容易引发缺陷"><a href="#漏写-break-容易引发缺陷" class="headerlink" title="漏写 break 容易引发缺陷"></a>漏写 break 容易引发缺陷</h3><p>有一种常见的错觉是程序只执行匹配成功的那个 case 分支的语句。例如，下面程序的统计结果是错误的：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-9.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-10.png" alt></p><h3 id="default-标签"><a href="#default-标签" class="headerlink" title="default 标签"></a>default 标签</h3><p>如果没有任何一个 case 标签可以匹配上 switch 表达式的值，程序将执行紧跟在<strong>default 标签（default label）</strong>后面的语句。</p><p>例如，可以增加一个计数值来统计非元音字母的数量，只要在 default 分支内不断递增变量就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'i'</span>: <span class="keyword">case</span> <span class="string">'o'</span>: <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ++other;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-11.png" alt></p><h3 id="switch-内部的变量定义"><a href="#switch-内部的变量定义" class="headerlink" title="switch 内部的变量定义"></a>switch 内部的变量定义</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-12.png" alt></p><h1 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h1><p>迭代语句通常称为循环语句，它重复执行操作直到满足某个条件。while 和 for 语句在执行循环体之前检查条件，do while 语句先执行循环体，然后再检查条件。</p><h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p>只要条件为<strong>真</strong>，<strong>while 语句（while statement）</strong>就重复执行循环体，它的语法形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>在 while 结构中，只要 condition 的求值结果为真就一直执行 statement （常常是一个块）。condition 不能为空，如果 condition 第一次求值就是<strong>false</strong>，则 statement 一次都不执行。</p><p>while 的条件部分可以是一个表达式或者是一个带初始化的变量声明。通常来说，应该由条件本身或者是循环体设法改变表达式的值，否则循环可能无法终止。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-13.png" alt></p><h3 id="使用-while-循环"><a href="#使用-while-循环" class="headerlink" title="使用 while 循环"></a>使用 while 循环</h3><p>当不确定到底要迭代多少次时，使用 while 循环比较合适，比如读取输入的内容就是如此。还有一种情况也应该使用 while 循环，这就是我们想在循环结束后访问循环控制变量。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// 重复读入数据，直至到达文件末尾或者遇到其他输入问题</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; i)</span><br><span class="line">    v.push_back(i);</span><br><span class="line"><span class="comment">// 寻找第一个负值元素</span></span><br><span class="line"><span class="keyword">auto</span> beg = v.begin();</span><br><span class="line"><span class="keyword">while</span> (beg != v.end() &amp;&amp; *beg &gt;= <span class="number">0</span>)</span><br><span class="line">    ++beg;</span><br><span class="line"><span class="keyword">if</span> (beg == v.end())</span><br><span class="line">    <span class="comment">// 此时我们知道 v 中的所有元素都大于等于0</span></span><br></pre></td></tr></table></figure><p>第一个循环从标准输入中读取数据，我们一开始不清楚循环要执行多少次，当 cin 读取到无效数据，遇到其他一些输入错误或是到达文件末尾时循环条件失效。</p><p>第二个循环重复执行直到遇到一个负值为止，循环终止后，beg 等于 v.end()，或者指向 v 中一个小于 0 的元素。可以在 while 循环外继续使用 beg 的状态以进行其他处理。</p><h2 id="传统的-for-语句"><a href="#传统的-for-语句" class="headerlink" title="传统的 for 语句"></a>传统的 for 语句</h2><p><strong>for 语句</strong>的语法形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (init-statement; condition; expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p><strong>关键字 for 及括号里的部分称作 for 语句头。</strong></p><p>init-statement 必须是以下三种形式中的一种：</p><ul><li>声明语句</li><li>表达式语句</li><li>空语句</li></ul><p>因为这些语句都以分号作为结束，所以 for 语句的语法形式也可以是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initializer; condition; expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>一般情况下，init-statement 负责初始化一个值，这个值将随着循环的进行而改变。condition 作为循环控制的条件，只要 condition 为真，就执行一次 statement。如果 condition 第一次的求值结果就是 false，则 statement 一次也不会执行。expression 负责修改 init-statement 初始化的变量，这个变量正好就是 condition 检查的对象，修改发生在每次循环迭代之后。statement 可以是一条单独的语句也可以是一条复合语句。</p><h3 id="传统-for-循环的执行流程"><a href="#传统-for-循环的执行流程" class="headerlink" title="传统 for 循环的执行流程"></a>传统 for 循环的执行流程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重复处理 s 中的字符直至我们处理完全部字符或者遇到了一个表示空白的字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.size()) index = <span class="number">0</span>; index != s.size() &amp;&amp; !<span class="built_in">isspace</span>(s[index]); ++index)</span><br><span class="line">    s[index] = <span class="built_in">toupper</span>(s[index]);  <span class="comment">// 将当前字符改写成大写形式</span></span><br></pre></td></tr></table></figure><p>求值的顺序如下所示：</p><ol><li>循环开始时，首先执行一次 init-statement。此例子中，定义 index 并初始化为 0 。</li><li>接下来判断 condition。如果 index 不等于 s.size() 而且在 s[index] 位置的字符不是空白，则执行 for 循环体的内容。否则，循环终止。如果第一次迭代时条件就为假，for 循环体一次也不会执行。</li><li>如果条件为真，执行循环体。此例中，for 循环体将 s[index] 位置的字符改写成大写形式。</li><li>最后执行 expression。此例中，将 index 的值加 1 。</li></ol><p>这 4 步说明了 for 循环第一次迭代的过程。</p><p>其中第 1 步只在循环开始时执行一次，第 2 3 4 步重复执行直到条件为假时终止，也就是在 s 中遇到一个空白字符或者 index 等于 s.size() 时终止。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-14.png" alt></p><h3 id="for-语句头中的多重定义"><a href="#for-语句头中的多重定义" class="headerlink" title="for 语句头中的多重定义"></a>for 语句头中的多重定义</h3><p>和其他的声明一样，init-statement 也可以定义多个对象。但是 init-statement 只能有一条声明语句，因此，所有变量的基础类型必须相同。</p><p>举个例子，我们用下面的循环把 vector 的元素拷贝一份添加到原来的元素后面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录下 v 的大小，当到达原来的最后一个元素后结束循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(v.size()) i = <span class="number">0</span>, sz = v.size(); i != sz; ++i)</span><br><span class="line">    v.push_back(v[i]);</span><br></pre></td></tr></table></figure><p>在这个循环中，我们在 init-statement 里同时定义了索引 i 和循环控制变量 sz。</p><h3 id="省略-for-语句头的某些部分"><a href="#省略-for-语句头的某些部分" class="headerlink" title="省略 for 语句头的某些部分"></a>省略 for 语句头的某些部分</h3><p>for 语句头能省略掉 init-statement，condition 和 expression 中的任何一个（或者全部）。</p><p>如果不需要初始化，则我们可以使用一条空语句作为 init-statement。例如，对于在 vector 对象中寻找第一个负数的程序，完全可以用 for 循环改写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> beg = v.begin();</span><br><span class="line"><span class="keyword">for</span> ( <span class="comment">/*空语句*/</span> ; beg != v.end() &amp;&amp; *beg &gt;= <span class="number">0</span>; ++beg)</span><br><span class="line">    ;  <span class="comment">// 什么都不做</span></span><br></pre></td></tr></table></figure><p>注意：<strong>分号必须保留以表明我们省略掉了 init-statement。</strong></p><p>说得更准确一点，分号表示的是一个空的 init-statement。在这个循环中，因为所有要做的工作都在 for 语句头的条件和表达式部分完成了，所以 for 循环体也是空的。其中，条件部分决定何时停止查找，表达式部分递增迭代器。</p><p>省略 condition 的效果等价于在条件部分写了一个 true。因为条件的值永远是 true，所以在循环体内必须有语句负责退出循环，否则循环就会无休止地执行下去：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">/*条件为空*/</span> ; ++i) &#123;</span><br><span class="line">    <span class="comment">// 对 i 进行处理，循环内部的代码必须负责终止迭代过程！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以省略掉 for 语句头中的 expression，但是在这样的循环中就要求条件部分或者循环体必须改变迭代变量的值。</p><p>举个例子，之前有一个将整数读入 vector 的 while 循环，我们使用 for 语句改写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i; <span class="built_in">cin</span> &gt;&gt; i; <span class="comment">/*表达式为空*/</span> )</span><br><span class="line">    v.push_back(i);</span><br></pre></td></tr></table></figure><p>因为条件部分能改变 i 的值，所以这个循环不需要表达式部分。其中，条件部分不断检查输入流的内容，只要读取完所有的输入或者遇到一个输入错误就终止循环。</p><h2 id="do-while-语句（do-while-statement）"><a href="#do-while-语句（do-while-statement）" class="headerlink" title="do while 语句（do while statement）"></a>do while 语句（do while statement）</h2><p>do while 语句和 while 语句十分相似，唯一的区别就是，do while 语句先执行循环体后检查条件。不管条件的值如何，我们都至少执行一次循环。do while 语句的语法形式如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-15.png" alt></p><p>在 do 语句中，求 condition 的值之前首先执行一次 statement，condition 不能为空。</p><p>如果 condition 的值为假，循环终止，否则，重复循环过程。condition 使用的变量必须定义在循环体之外。</p><p>我们可以使用 do while 循环（不断地）执行加法运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不断提示用户输入一对数，然后求其和</span></span><br><span class="line"><span class="built_in">string</span> rsp;  <span class="comment">// 作为循环的条件，不能定义在 do 内部</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"please enter two values: "</span>;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">0</span>, val2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; val1 &gt;&gt; val2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of "</span> &lt;&lt; val1 &lt;&lt; <span class="string">" and "</span> &lt;&lt; val2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; val1 + val2 &lt;&lt; <span class="string">"\n\n"</span> &lt;&lt; <span class="string">"More? Enter yes or no: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; rsp;</span><br><span class="line">&#125; <span class="keyword">while</span> (!rsp.empty() &amp;&amp; rsp[<span class="number">0</span>] != <span class="string">'n'</span>);</span><br></pre></td></tr></table></figure><p>循环首先提示用户输入两个数字，然后输出和并询问是否继续。条件部分检查用户的回答，如果用户没有回答，或者用户的回答以字母 n 开始，循环都将终止。否则循环继续执行。</p><p>因为对于 do while 来说先执行语句或者块，后判断条件，所以不允许在条件部分定义变量，如果允许，则变量的使用出现在定义之前，这显然是不合常理的！</p><h1 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h1><p>跳转语句中断当前的执行过程。C++语言提供了 4 种跳转语句：break，continue，goto 和 return。此笔记暂时记录前三种跳转语句。</p><h2 id="break-语句（break-statement）"><a href="#break-语句（break-statement）" class="headerlink" title="break 语句（break statement）"></a>break 语句（break statement）</h2><p><strong>break 语句</strong>负责终止离它最近的 while，do while，for 或 switch 语句，并从这些语句之后的第一条语句开始继续执行。</p><p>break 语句只能出现在迭代语句或者 switch 语句内部（包括嵌套在此类循环里的语句或块的内部）。break 语句的作用范围仅限于最近的循环或者 switch。</p><h2 id="continue-语句（continue-statement）"><a href="#continue-语句（continue-statement）" class="headerlink" title="continue 语句（continue statement）"></a>continue 语句（continue statement）</h2><p><strong>continue 语句</strong>终止最近的循环中的当前迭代并立即开始下一次迭代。continue 语句只能出现在 for，while 和 do while 循环的内部，或者嵌套在此类循环里的语句或块的内部。</p><ul><li>和 break 语句类似的是：出现在嵌套循环中的 continue 语句也仅作用于离它最近的循环。</li><li>和 break 语句不同的是：只有当 switch 语句嵌套在迭代语句内部时，才能在 switch 里使用 continue。</li></ul><p>continue 语句中断当前的迭代，但是仍然继续执行循环。</p><ul><li>对于 while 或者 do while 语句来说，继续判断条件的值。</li><li>对于传统的 for 循环来说，继续执行 for 语句头的 expression。</li><li>对于范围 for 语句来说，则是用序列中的下一个元素初始化循环控制变量。</li></ul><h2 id="goto-语句（goto-statement）"><a href="#goto-语句（goto-statement）" class="headerlink" title="goto 语句（goto statement）"></a>goto 语句（goto statement）</h2><p><strong>goto 语句</strong>的作用是从 goto 语句无条件跳转到同一函数内的另一条语句。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-16.png" alt></p><p>goto 语句的语法形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure><p>其中，label 是用于标记和识别一条语句的标示符。<strong>带标签语句（labeled statement）</strong>是一种特殊的语句，在它之前有一个标示符以及一个冒号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end: <span class="keyword">return</span>;  <span class="comment">// 带标签语句，可以作为 goto 目标</span></span><br></pre></td></tr></table></figure><p>标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。goto 语句和控制权转向的那条带标签的语句必须位于同一个函数之内。</p><p>和 switch 语句类似，goto 语句也不能将程序的控制权从变量的作用域之外转移到作用域之内：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/second-week-17.png" alt></p><p>向后跳过一个已经执行的定义是合法的。跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向后跳过一个带初始化的变量定义是合法的</span></span><br><span class="line">begin:</span><br><span class="line">    <span class="keyword">int</span> sz = get_size();</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> begin;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，goto 语句执行后将销毁 sz。因为跳回到 begin 的动作跨过了 sz 的定义语句，所以 sz 将重新定义并初始化。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p><p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Primer第一周的笔记</title>
      <link href="/about-cpp/2019/the-first-week-for-C++.html"/>
      <url>/about-cpp/2019/the-first-week-for-C++.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一个Hello-World"><a href="#第一个Hello-World" class="headerlink" title="第一个Hello World"></a>第一个<code>Hello World</code></h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-1.jpg" alt></p><p>这是基于C++ Primer的第一周笔记，主要内容为C++的基本语句和逻辑运算，数据类型与基础表达式。详细请见C++ Primer的1.1节至1.3节，2.1节至2.2节，4.1节至4.5节和4.11.1节。</p><a id="more"></a><p>都说程序员写毛笔字都是提笔就是Hello World，那么C++的第一个程序介绍也从这里开始吧！</p><p>C++的基本构造是从函数（function）开始，其中必有一个main函数，所以C++的基本模版如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的main必定属于int类型，所以需要int进行调用和命名。return为最基本的返回项，可有可无，特定情况下仅仅为保留结果和显示。</p><p><strong>重点：每一句结尾都得有一个 ; 这可能会经常被遗忘！</strong></p><p>关于C++的编译和运行，详情可见<a href="https://liutiantian233.github.io/tech/2019/mac-cpp-environment.html">C++的最佳环境</a></p><h1 id="C-的输入和输出"><a href="#C-的输入和输出" class="headerlink" title="C++的输入和输出"></a>C++的输入和输出</h1><p>C++与Python不同的是没有内置最基本的 I/O 语句，采用的是STL库（standard library）来进行 I/O 输入和输出。其中最基本的<strong>标准输入</strong>和<strong>标准输出</strong>分别为<strong>cin</strong>和<strong>cout</strong>。当然标准库里还有两个基本语句<strong>cerr</strong>和<strong>clog</strong>分别为错误和警告。</p><h2 id="一个标准程序"><a href="#一个标准程序" class="headerlink" title="一个标准程序"></a>一个标准程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行就是调用C++的基础STL标准库，俗称头文件。</p><h2 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h2><p>在main函数中的：</p><p><code>std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;</code></p><p><code>&lt;&lt;</code>叫做<strong>输出运算符</strong>，<code>endl</code>叫做<strong>操纵符</strong>，作用分别为输出和短暂缓冲数据。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>这里读取数据采用的是<code>cin</code>语句，通常为：</p><p><code>std::cin &gt;&gt; v1;</code></p><p><code>&gt;&gt;</code>叫做<strong>输入运算符</strong>，作用显而易见，作为输入数据。</p><h1 id="C-中注释的方法"><a href="#C-中注释的方法" class="headerlink" title="C++中注释的方法"></a>C++中注释的方法</h1><p>还记得2018年程序员界最火🔥的两大新闻吗，除了删库跑路，另一个就是同事不写注释，程序员暴走这条了。所以来说，任何程序都应该使用注释来使程序更加易读和易懂。</p><h2 id="C-注释的种类"><a href="#C-注释的种类" class="headerlink" title="C++注释的种类"></a>C++注释的种类</h2><p>C++有两种注释，分别为单行和多行注释。单行注释为双斜线开始（//）至此行结束，多行注释为（/*）开始，（*/）结束。</p><p>值得注意的是，多行注释无法嵌套注释，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 嵌套 /* 注释 */</span></span><br><span class="line"> * 是不可行的</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>C++中的数据类型包括<strong>算数类型</strong>（arithmetic type）和<strong>空类型</strong>（void），其中空类型不做任何具体的值。</p><h2 id="算数类型"><a href="#算数类型" class="headerlink" title="算数类型"></a>算数类型</h2><p>而算数类型又分为<strong>整型</strong>（包括字符和布尔）和<strong>浮点型</strong>。它们的数据尺寸如下：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-2.png" alt></p><h2 id="类型转换（convert）"><a href="#类型转换（convert）" class="headerlink" title="类型转换（convert）"></a>类型转换（convert）</h2><p>顾名思义，这是一种强行将一种类型转换成另一种类型的转换。对于这种转换，在C++中也是允许合法的。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="number">42</span>;     <span class="comment">// b 为 true</span></span><br><span class="line"><span class="keyword">int</span> i = b;       <span class="comment">// i 为 1</span></span><br><span class="line">i = <span class="number">3.14</span>;        <span class="comment">// i 为 3</span></span><br><span class="line"><span class="keyword">double</span> pi = i;   <span class="comment">// pi 为 3.0</span></span><br></pre></td></tr></table></figure><h2 id="字面值常量（literal）"><a href="#字面值常量（literal）" class="headerlink" title="字面值常量（literal）"></a>字面值常量（literal）</h2><p>每一个字面值常量都对应了一个数据类型，它们的形式和值决定了它们的数据类型。</p><h3 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h3><p>整型字面值可以写成十进制，八进制，十六进制等，0开头的整数为八进制，0x或者0X开头的为十六进制。我们可以用以下任意一种方法代表20：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>     <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">024</span>    <span class="comment">// 八进制</span></span><br><span class="line"><span class="number">0x14</span>   <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure><p>浮点型字面值一般表现为一个小数或者科学记数法表示的指数，其中指数使用E或者e。</p><h3 id="字符和字符串表示的字面值"><a href="#字符和字符串表示的字面值" class="headerlink" title="字符和字符串表示的字面值"></a>字符和字符串表示的字面值</h3><p>单引号为字符字面值，双引号为字符串字面值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span>        <span class="comment">// 字符字面值</span></span><br><span class="line"><span class="string">"Hello"</span>    <span class="comment">// 字符串字面值</span></span><br></pre></td></tr></table></figure><h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p>一些情况下需要用到转义序列打印<strong>不可打印</strong>的符号，比如：</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-3.png" alt></p><h3 id="布尔字面值"><a href="#布尔字面值" class="headerlink" title="布尔字面值"></a>布尔字面值</h3><p>true 和 flase 是布尔类型的字面值。</p><h1 id="变量（variable）"><a href="#变量（variable）" class="headerlink" title="变量（variable）"></a>变量（variable）</h1><p>变量在C++中是一种存储类型，可参与运算。</p><h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><p>首先是<strong>类型说明符（type specifier）</strong>，之后是一个或多个变量，逗号分隔，分号结束。</p><h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3><p>当对象获得了一个特定的值，我们称之为对象被<strong>初始化（initialized）</strong>了。</p><p><strong>重点：C++中初始化和赋值是两个完全不同的操作！</strong></p><h3 id="列表初始化（list-initialization）"><a href="#列表初始化（list-initialization）" class="headerlink" title="列表初始化（list initialization）"></a>列表初始化（list initialization）</h3><p>C++有几种不同的初始化方式，如下，初始化变量 a 为 0：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>使用中括号初始化在C++11中全面应用。其中的特点是，如果初始化存在丢失数据的风险时，编译器会报错。</p><h3 id="默认初始化（default-initilized）"><a href="#默认初始化（default-initilized）" class="headerlink" title="默认初始化（default initilized）"></a>默认初始化（default initilized）</h3><p>默认值由变量类型决定！</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-4.png" alt></p><h2 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h2><p>C++允许<strong>分离式编译（separate compilation）</strong>机制，该机制运行原理为：将程序分隔为若干文件，每个文件可以被独立编译。</p><p>而为了支持分离式编译，C++将声明和定义区分开，<strong>声明（declaration）</strong>让程序所知，一个文件如果想使用别处定义的名字，必须包含对那个名字的声明，而<strong>定义（definition）</strong>负责创建与名字关联的实体。</p><p>如果想声明变量而不去定义，则添加关键词<code>extern</code>！</p><p><strong>注意：变量能且只能被定义一次，却可以被多次声明！</strong></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-5.png" alt></p><h2 id="标识符（identifier）"><a href="#标识符（identifier）" class="headerlink" title="标识符（identifier）"></a>标识符（identifier）</h2><p>由字母数字和下划线组成，必须以字母和下划线开头，对大小写敏感。</p><p>如下表，C++本身使用的名字不可作为标识符。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-6.png" alt></p><h3 id="一般性规则"><a href="#一般性规则" class="headerlink" title="一般性规则"></a>一般性规则</h3><p>以下规则提高可读性：</p><ul><li>体现实际含义</li><li>一般用小写字母</li><li>自定义的类名称一般大写字母开头</li><li>由多个单词组成需区分单词</li></ul><h2 id="名字的作用域（scope）"><a href="#名字的作用域（scope）" class="headerlink" title="名字的作用域（scope）"></a>名字的作用域（scope）</h2><p>不论在程序的什么位置，使用到的每一个名字都会指向一个实体。然而，同一个名字如果出现在程序不同的位置也可能是指向不同的实体。<strong>作用域</strong>一般都是以花括号分隔。</p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-7.png" alt></p><h3 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h3><p>作用域可以被彼此包含，<strong>内层作用域（inner scope）</strong>和<strong>外层作用域（outer scope）</strong>。作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在<strong>内层作用域</strong>中重新定义<strong>外层作用域</strong>已有的名字。</p><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>表达式由一个或多个<strong>运算对象（operand）</strong>组成，对表达式求值将得到一个<strong>结果（result）</strong>。字面值和变量是最简单的<strong>表达式（expression）</strong>。把一个<strong>运算符（operator）</strong>和一个或多个运算对象组合就是复杂的表达式。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>C++定义了<strong>一元运算符（unary operator）</strong>和<strong>二元运算符（binary operator）</strong>。</p><h3 id="组合运算符和运算对象"><a href="#组合运算符和运算对象" class="headerlink" title="组合运算符和运算对象"></a>组合运算符和运算对象</h3><p>即运算对象的<strong>求值顺序（order of evaluation）</strong>包括<strong>优先级（precedence）</strong>和<strong>结合律（associativity）</strong>。</p><h3 id="运算对象转换"><a href="#运算对象转换" class="headerlink" title="运算对象转换"></a>运算对象转换</h3><p>详见<strong>算数转换</strong></p><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p>即自定义运算符。</p><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>这是一个继承C语言中的概念，但是在C++中就不是那么容易理解的：</p><ul><li><strong>左值表达式</strong>的求值结果是一个对象或者是一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左值运算对象。</li><li>虽然某些表达式的求值结果是对象，但它们是右值，非左值。</li></ul><p>做一个简单的归纳：<strong>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</strong></p><p><strong>重点！！！</strong></p><h2 id="优先级和结合律"><a href="#优先级和结合律" class="headerlink" title="优先级和结合律"></a>优先级和结合律</h2><p>即<strong>复合表达式（compound expression）</strong>，<strong>括号无视优先级和结合律</strong>。</p><h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>优先级规定了运算对象的组合方式，但没有说明运算对象按照什么顺序求值。大多数情况下，不会明确指定求值的顺序。</p><p>其中有四种运算符规定了求值顺序，它们分别是<strong>逻辑与</strong>，<strong>逻辑或</strong>，<strong>条件运算符</strong>和<strong>逗号运算符</strong>。</p><h3 id="求值顺序和优先级结合律"><a href="#求值顺序和优先级结合律" class="headerlink" title="求值顺序和优先级结合律"></a>求值顺序和优先级结合律</h3><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-10.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-11.png" alt></p><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-8.png" alt></p><p>上表按照优先级排序，以上所有都满足左结合律，意味着当优先级相同时，从左向右顺序进行组合。<strong>算数运算符的运算对象和求值结果都是右值。</strong></p><h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><p><strong>逻辑和关系运算符的运算对象和求值结果都是右值。</strong></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-9.png" alt></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><strong>赋值运算满足右结合律！赋值运算优先级较低！切勿混淆相等运算符和赋值运算符！</strong></p><h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-12.png" alt></p><h1 id="算数转换（arithmetic-conversion）"><a href="#算数转换（arithmetic-conversion）" class="headerlink" title="算数转换（arithmetic conversion）"></a>算数转换（arithmetic conversion）</h1><h2 id="整数提升"><a href="#整数提升" class="headerlink" title="整数提升"></a>整数提升</h2><p>负责把小整数类型提升至较大的整数类型。</p><h2 id="理解算数转换"><a href="#理解算数转换" class="headerlink" title="理解算数转换"></a>理解算数转换</h2><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-13.png" alt></p><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/first-week-14.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p><p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于CPP的学习手册</title>
      <link href="/about-cpp/2019/about-cpp-study-manual.html"/>
      <url>/about-cpp/2019/about-cpp-study-manual.html</url>
      
        <content type="html"><![CDATA[<h1 id="按照惯例-写在前面"><a href="#按照惯例-写在前面" class="headerlink" title="按照惯例 写在前面"></a>按照惯例 写在前面</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/about-cpp-study-manual-1.jpg" alt></p><p>这是一个用于CS专业的学生或有志于进行更深入地了解编程的人。开始通过引入C++语言和标准模板库STL，使用由C++11的标准添加最新的元件，并且移动到更先进的数据结构和算法工作。</p><a id="more"></a><p>准确的说，这其实只能算是一个关于我学习C++过程中的检索与目录，我可不认为几篇简简单单的博客，就可以统筹概括完C++详细的知识点，越是经过深度的学习，越是发觉C++的强大，不可与同日的Python相比。</p><p>我记得在知乎上有人把C++和物理作类比，我很同意。理论物理是一场无尽的旅程，总有最前沿的东西。</p><blockquote><p>我从小就对物理感兴趣，于是我开始钻研物理，到现在，我早已是物理学博士，可我仍然不知道物理到底是什么。</p></blockquote><p>所以我的求知欲只能暂且到此为止，C++亦是如此！</p><p>到起草这篇博客开始，现在已经开学三周了。C++简单的皮毛也了解了一下，主要的程序和实验问题，我将会逐步更新至我的GitHub之上。</p><h1 id="目录与检索"><a href="#目录与检索" class="headerlink" title="目录与检索"></a>目录与检索</h1><p>看目录之前先讲个笑话：</p><blockquote><p>C语言说：我们提供标准外壳，零件和电子元件，您可以一个零件一个零件，亲手组装出任何机器。</p><p>Python说：我就像DIY爱好者的3D打印机一样，作为编程语言中真正的多面手，我们致力于让用户轻松地完成他们的工作。另外，我们也有巨量的套壳件，能让你用我们的方式使用友商的产品。不过，为了加工的方便，我们的作品一向是以塑料为主要材质的。所以请不要让它干太重的活，否则可能受不了如此沉重的折磨！</p><p>Go等其他语言：我们提供专门为某一类产品定制的集成模块，比如发动机，变速箱等等，您可以利用这些模块定制化特定种类的产品。</p><p>Java语言：我们是软件行业的蒸汽朋克，是工业时代的杰出代表。我们的产品一向以大负载，强功率著称，是你处理大量需求的不二选择。不过，请不要频繁地开关这些大家伙，因为那样的话你将浪费90%的燃料在预热机器上。</p><p>C++语言：我们提供这个世界上所有产品的集成模块，您可以快速地制作任何东西。相应地，我们还有一本长达1000页的产品说明，请务必仔细阅读，以免您不幸将飞机螺旋桨怼到潜水艇上。</p></blockquote><p>至于为什么要讲这个笑话，因为我想说：<strong>C++语言的野心非常大，但，你的野心不必这么大！</strong></p><p>并且随着大野心C++的逐步更新，一切教程语言都是会被改变，所以我推荐的第一个目录就在这里，<a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">中文的C++官方手册</a>，一切以官方为准。</p><ol><li>第零周：关于C++的入门<ol><li><a href="https://liutiantian233.github.io/tech/2019/mac-cpp-environment.html">对于环境的搭建与编译器的选择</a></li><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-first-week-for-C++.html">一个简单的C++程序</a></li><li><a href="https://liutiantian233.github.io/about-cpp/2019/UNIX-basic-commands.html">UNIX的基础命令</a></li></ol></li><li>第一周：变量类型与表达式，算数运算<ol><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-first-week-for-C++.html">论述部分</a></li><li>第一周的<a href="https://github.com/liutiantian233/CPP-Lab/tree/master/Lab01" target="_blank" rel="noopener">实验程序</a>和<a href="https://github.com/liutiantian233/CPP-Project/tree/master/Proj01" target="_blank" rel="noopener">项目</a></li></ol></li><li>第二周：控制语句<ol><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-second-week-for-C++.html">论述部分</a></li><li>第二周的<a href="https://github.com/liutiantian233/CPP-Lab/tree/master/Lab02" target="_blank" rel="noopener">实验程序</a>和<a href="https://github.com/liutiantian233/CPP-Project/tree/master/Proj02" target="_blank" rel="noopener">项目</a></li></ol></li><li>第三周：函数和更多的程序类型<ol><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-third-week-for-C++-1.html">论述部分-1</a></li><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-third-week-for-C++-2.html">论述部分-2</a></li><li>第三周的<a href="https://github.com/liutiantian233/CPP-Lab/tree/master/Lab03" target="_blank" rel="noopener">实验程序</a>和<a href="https://github.com/liutiantian233/CPP-Project/tree/master/Proj03" target="_blank" rel="noopener">项目</a></li></ol></li><li>第四周：字符和字符串的标准模版库<ol><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-fourth-week-for-C++.html">论述部分</a></li><li>第四周的<a href="https://github.com/liutiantian233/CPP-Lab/tree/master/Lab04" target="_blank" rel="noopener">实验程序</a>和<a href="https://github.com/liutiantian233/CPP-Project/tree/master/Proj04" target="_blank" rel="noopener">项目</a></li></ol></li><li>第五周：函数和更多的程序类型<ol><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-fifth-week-for-C++-1.html">论述部分-1</a></li><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-fifth-week-for-C++-2.html">论述部分-2</a></li><li>第五周的<a href="https://github.com/liutiantian233/CPP-Lab/tree/master/Lab05" target="_blank" rel="noopener">实验程序</a>和<a href="https://github.com/liutiantian233/CPP-Project/tree/master/Proj05" target="_blank" rel="noopener">项目</a></li></ol></li><li>第六周：头文件和Vector<ol><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-sixth-week-for-C++.html">论述部分</a></li><li>第六周的<a href="https://github.com/liutiantian233/CPP-Lab/tree/master/Lab06" target="_blank" rel="noopener">实验程序</a>和<a href="https://github.com/liutiantian233/CPP-Project/tree/master/Proj05" target="_blank" rel="noopener">项目</a></li></ol></li><li>第七周：异常处理和迭代器<ol><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-seventh-week-for-C++-1.html">论述部分-1</a></li><li><a href="https://liutiantian233.github.io/about-cpp/2019/the-seventh-week-for-C++-2.html">论述部分-2</a></li><li>第五周的<a href="https://github.com/liutiantian233/CPP-Lab/tree/master/Lab07" target="_blank" rel="noopener">实验程序</a>和<a href="https://github.com/liutiantian233/CPP-Project/tree/master/Proj06" target="_blank" rel="noopener">项目</a></li></ol></li></ol><p>粗略地说，我的这篇开发手册将被划分为两个部分：</p><ul><li>学习C++和STL，并将它应用到一些实际例子。</li><li>建立我们自己的数据结构和算法（内存管理，模板等等）</li></ul><p>我介绍一些课题是：选择和迭代，字符串，函数，其他的数据结构（载体，字符串，地图等）文件的I/O和通用的算法，最后是用户自定义的Class。</p><h1 id="关于编码的规则"><a href="#关于编码的规则" class="headerlink" title="关于编码的规则"></a>关于编码的规则</h1><p>在这个过程中，我们将遵守一套约定关于我们如何在程序命名变量，函数和常量，我们如何缩进等。虽然编码规则往往是任意的，选择一个一致的组织。我们将选择使用<a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">谷歌编码标准</a>，可以在那里寻找，并找到正确的标准答案。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.cppreference.com/w/首页" target="_blank" rel="noopener">来自官方手册</a></p><p>C++ Primer中文译本（由于文件过大，需自行下载或<a href="https://liutiantian233.github.io/about/">联系我</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 关于C++的学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac的CPP环境最佳搭建方案</title>
      <link href="/tech/2019/mac-cpp-environment.html"/>
      <url>/tech/2019/mac-cpp-environment.html</url>
      
        <content type="html"><![CDATA[<h1 id="重要-写在前面"><a href="#重要-写在前面" class="headerlink" title="重要 写在前面"></a>重要 写在前面</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/20181230/%E5%9B%BE%E7%89%872.jpg" alt></p><p>因为新学期的到来，Python这个小婊砸算是暂时打入冷宫，让她自闭一会，毕竟太能折腾。C++作为业界典范，上能通R语言，Go语言，下能打C语言和Java语言，行业老大哥。所以一切的开始，都得从最基本的搭建环境开始讲起！</p><a id="more"></a><p>我先介绍下：</p><ol><li>文本编辑器：就是写代码的东西，再直白点，记事本就是一种文本编辑器，此外还有著名的Sublime，Atom，Visual Studio，NodePad++，等等。</li><li>编译器：这个的作用就是把你之前用文本编辑器写的代码翻译成机器代码的一个程序。</li><li>连接器：将你写的代码翻译成二进制机器代码后，与系统提供的二进制库进行组合的程序，其结果是生成一个可执行的文件。因为基本所有代码都不是一个人做的，都是现在前人的成果上选出一部分进行再造。编译器和连接器通常是通常是一起的，常见的有VC/VC++，GCC/G++等等。</li><li>调试器：即对可执行的代码一点一点运行，然后把运行的信息显示出来，结合这些信息判断逻辑上哪里有错误，也就是俗称的Debug工具。</li><li>项目管理工具：一个管理程序项目的程序，比如源文件放哪，用什么语法级别，连接器可用的链接库放在哪等等。</li><li>集成开发环境（IDE）：这个东西就是把上面所有类型的工具选一些出来组合，然后再自己增加一些语法检查等人性化的功能，直接的效果就是有这个工具就能直接开发了。常见的有Eclipse，Visual Stdio，Clion等等。</li></ol><p>接下来就是如何进行一个开发了，<strong>有两种选择</strong>，一种是所有的工具都知道，每样选一个工具进行开发，比如Mac下，用Sublime写一段代码，GCC编译链接，然后执行。</p><p>当然如果不是很清楚，那就直接下载集成环境，按照提示写程序运行程序就可以了。</p><p><strong>新手推荐用IDE集成环境</strong></p><h1 id="关于各个IDE的测评和简单介绍"><a href="#关于各个IDE的测评和简单介绍" class="headerlink" title="关于各个IDE的测评和简单介绍"></a>关于各个IDE的测评和简单介绍</h1><p>因为新手最要紧的不是弄懂编程语言是怎么回事，编程应该怎么操作，只有在学习更加深入之后，回过头来再了解什么叫编译，什么叫链接，如何写出不用链接也能执行的代码，如何写出不用操作系统也能执行的代码等。</p><h2 id="关于IDE"><a href="#关于IDE" class="headerlink" title="关于IDE"></a>关于IDE</h2><ol><li>Visual Stdio：号称宇宙最强的C++集成环境，其实他已经不再是普通意义上的一种IDE了，而是一种平台，基本任何程序都可以在上面编写，还可以做商务智能，绘图，数据库管理等等一系列功能。目前只有Windows版本，虽然爆炸性的说有了Mac的预览版然后又匆匆删去，其实不抱有任何希望，毕竟和Windows贴合太紧密了！</li><li>Eclipse：用Java语言实现的IDE，跨平台，但是因为是建立在虚拟机上的，所以性能和外观有一定的败笔，其与Visual Stdio一样，是一个平台，有无数插件可以编写，一瞬间是Java的IDE，转瞬一变就是C和C++的IDE了，当然Python什么等等都可以。</li><li>Xcode：Mac下推荐Xcode，教程多，不用担心出错找不到怎么办。</li><li>Clion：这个是基于CMake构建的，但真的很好，我觉得是Mac的首选，我就一直在用这个。</li><li>CodeBlock：跨平台，但貌似很久不更新了。</li></ol><h1 id="使用Mac的终端搭建"><a href="#使用Mac的终端搭建" class="headerlink" title="使用Mac的终端搭建"></a>使用Mac的终端搭建</h1><ol><li>检查环境</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/mac-cpp-environment-1.png" alt></p><ol start="2"><li>编写源代码</li><li>编译链接代码</li><li>运行</li></ol><p>这是一个基本的运行流程，但不是很建议这样操作，对新手不是很友好。所以我推荐直接使用Clion的IDE进行搭建，有学生优惠，使用学校邮箱注册一个学生账号就能免费使用。Xcode的话虽然臃肿，但使用还是没问题的，而且又是Mac的亲儿子，你看，隔壁家的微软和VS，你侬我侬的。</p><h1 id="关于Clion"><a href="#关于Clion" class="headerlink" title="关于Clion"></a>关于Clion</h1><p>我真的真的必须强烈推荐，别跟我说什么新手不会用CMake。</p><p><strong>新建一个项目的时候哪里需要手动改CMakeLists文件？？？</strong></p><p><strong>新建一个Class也不会需要手动改CMakeLists文件！！！</strong></p><h1 id="总结与引用"><a href="#总结与引用" class="headerlink" title="总结与引用"></a>总结与引用</h1><p>对于任何初学语言和开发来说，集成的工具总是好的，实用性强，但如果使用单一软件会更利于产品兼容。各有千秋吧！</p><p><a href="https://www.zhihu.com/question/23677882/answer/131325334" target="_blank" rel="noopener">来自知乎的部分</a>部分参考</p>]]></content>
      
      
      <categories>
          
          <category> 技术-tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Macbook Pro相关 </tag>
            
            <tag> 产品技术测评-Product technology evaluation </tag>
            
            <tag> C++的开发和进度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Mac Touch ID失灵的原因和综合解决办法</title>
      <link href="/tech/2019/about-mac-touch-id-failure.html"/>
      <url>/tech/2019/about-mac-touch-id-failure.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/about-mac-touch-id-failure.jpg" alt></p><p>Mac随着更新迭代的时间越来越快，其实用性的确在越来越强，但伴随着的是一堆如同Windows一般的严重又无法查明具体原因的Bug，这里详细讨论一下一个目前还没有在国内论坛和网站普及的Macbook Pro 2018款之后的版本出现的一个关于Touch ID的Bug。</p><a id="more"></a><p>如果你遇到 Mac OS 无法添加指纹的情况，这一般是会出现在 Macbook Pro 2018款或者更高版本的电脑（2016款带指纹的版本也可能会出现）这就是一篇关于形成这个Bug的原因和解决办法。</p><h2 id="解决之前"><a href="#解决之前" class="headerlink" title="解决之前"></a>解决之前</h2><p>作为一个专（dan）业（ten）的计算机痴迷用户，并且全身家当最贵的就是这个电脑。无数次被这个Bug怼得头皮发麻。尽管坐标美国，每次去联系学校的Apple Store，都是被热心的换了一台新的，而且每次都是单机带去，全新拿回来，我甚至都想天天换电脑了。但问题还是问题，解决还是得解决。</p><p>就目前从国内论坛和网站中，还没有关于这类问题的解决办法。天才吧也不例外。我不能说天才吧里没人知道，但至少这个办法没有被普及。在国外论坛浸泡了好久，终于还是找到了。</p><h1 id="这个Bug的形成原因"><a href="#这个Bug的形成原因" class="headerlink" title="这个Bug的形成原因"></a>这个Bug的形成原因</h1><p>我们先来解释一下Touch Bar的工作原理，就目前的Touch Bar来说，官方解释是这样的：</p><blockquote><p>The all-new Touch Bar revolutionizes the keyboard experience by bringing dynamic controls to your fingertips. This Multi-Touch Retina display at the top of the new MacBook Pro keyboard changes depending on what the user does in your app, so you can surface context-specific features and controls.</p></blockquote><p>解释的很笼统，让你觉得这个Bar是依附于Macbook的硬盘或者系统中，事实上，其存储器和运行解析器，都是单独运行的，与Mac OS的硬盘系统属于并列关系。互不干涉。这就导致了一个严重的问题：</p><blockquote><p>如果第一次电脑恢复出厂设置之前，没有清空Touch Bar内置存储器的信息，信息就会被残留，并且在新安装的电脑里，无法清理这个残留文件，且！！！存储器内存有上限，达到一定程度就无法继续添加。</p></blockquote><p>这样就明白很多了吧，如果你第一次开机录入了10个手指，并且指纹上限就是10个，如果你的电脑升级了系统，或者出现问题，恢复出厂设置，一旦步骤中需要你重新录入指纹，系统发现Touch Bar内存已经满了。就会跳过步骤，而且你也无法手动添加。</p><p><strong>就会导致你一直无法添加新的指纹！！！</strong></p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>如果已经遇到了这个问题，那么解决办法如下：</p><ol><li><p>重新启动Mac并立即按住<code>command</code>+<code>R</code>键开机，进入恢复模式。</p></li><li><p>在<code>Mac实用工具</code>选项中，下拉<code>工具</code>菜单，选择终端。</p></li><li><p>在命令行输入以下命令，然后按回车：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xartutil --erase-all</span><br></pre></td></tr></table></figure><ol start="4"><li><p>当询问是否要继续时，输入<code>yes</code></p></li><li><p>点击  标志菜单并选择<code>重新启动</code>，和正常启动一样，之后重新进入恢复模式安装系统。</p></li></ol><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/201901/touch-bar-terminal.jpg" alt></p><p>如果你即将恢复出厂设置，如下操作可以避免日后出现问题：</p><ol><li>从  标志菜单打开系统偏好设置，然后选择Touch ID</li><li>删除当前所有指纹。</li></ol><p>或许你也可以试着重置 Mac 上的 NVRAM 或 PRAM 和 SMC 解决一些基本的问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我想这个问题形成的原因还是Touch Bar和系统之间没有做好调节导致的，但毕竟还是可以解决的。希望以后可以尽快改进吧。</p><p>或许我的描述没有让你更理解，请<a href="https://liutiantian233.github.io/about/">联系我</a>提供建议，我会给予你最大的帮助。</p><p>感谢你的阅读！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://osxdaily.com/2017/12/21/delete-touch-bar-data-mac/" target="_blank" rel="noopener">MacOS日常</a></p><p><a href="https://support.apple.com/zh-cn/HT204063" target="_blank" rel="noopener">重置 Mac 上的 NVRAM 或 PRAM</a></p><p><a href="https://support.apple.com/zh-cn/HT201295" target="_blank" rel="noopener">如何重置 Mac 上的系统管理控制器 (SMC)</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术-tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Macbook Pro相关 </tag>
            
            <tag> 产品技术测评-Product technology evaluation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Development Manual And Debugging</title>
      <link href="/tech/2019/development-manual-and-debug.html"/>
      <url>/tech/2019/development-manual-and-debug.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用Hexo-NexT搭建博客"><a href="#使用Hexo-NexT搭建博客" class="headerlink" title="使用Hexo+NexT搭建博客"></a>使用Hexo+NexT搭建博客</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/20181230/20181230.jpg" alt></p><p>关于NexT建站的详细流程笔记和开发手册，主要部分是Mist主题的侧边栏切换和各种模块的添加使用，之后会持续更新关于Debug与参考链接。</p><a id="more"></a><h1 id="必读-写在前面"><a href="#必读-写在前面" class="headerlink" title="必读 写在前面"></a>必读 写在前面</h1><p>基于<code>Hexo</code>模块化结构和<code>NexT</code>主题进行搭建的博客详细开发手册</p><p><strong>哥林多后书5章17节</strong></p><ul><li>若有人在基督里，他就是新造的人，旧事已过，都变成新的了。</li></ul><p>如果每一个超棒的想法都能汇聚在相应的小河之中，那么文明的大河将会迅速变成大海。一切都是从无到有，感谢互联网，让开源共享精神照耀了这个时代，让这个设想有了真正的可能。</p><p>本文就是一篇关于利用 GitHub Pages + Hexo + NexT 搭建个人博客的文章。</p><h2 id="重要的提示"><a href="#重要的提示" class="headerlink" title="重要的提示"></a>重要的提示</h2><p>站点配置文件和主题配置文件，名字都叫<code>_config.yml</code>需要仔细阅读分清楚。</p><ul><li><p>站点配置文件，位于站点文件夹根目录内：</p><p><code>/Users/onelai/Documents/Blog</code></p></li><li><p>主题配置文件，位于主题文件夹根目录内：</p><p><code>/Users/onelai/Documents/Blog/themes/next</code></p></li></ul><h2 id="我的搭建环境"><a href="#我的搭建环境" class="headerlink" title="我的搭建环境"></a>我的搭建环境</h2><p>因为不同的操作环境有着极其大的区别，搭建期间踩过很多雷，所以特别声明一下我的操作环境为：</p><ul><li>Mac OS High Sierra 10.13.6</li><li><a href="https://brew.sh" target="_blank" rel="noopener">Homebrew</a></li><li><a href="https://git-scm.com" target="_blank" rel="noopener">Git</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node</a></li><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></li></ul><h1 id="开始-搭建博客"><a href="#开始-搭建博客" class="headerlink" title="开始 搭建博客"></a>开始 搭建博客</h1><p>基本环境的具体流程可以在<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener"><code>Hexo</code>官方手册</a>中找到，我的步骤是：</p><p><strong>打开系统自带终端标签页，安装<code>Homebrew</code>包管理模块，输入<code>brew</code>操作命令安装<code>Git</code>和<code>Node</code>包版本，最后使用<code>npm</code>命令安装<code>Hexo</code>最新版本。</strong></p><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p>打开终端运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;开发手册与调试&quot;</span><br></pre></td></tr></table></figure><h2 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>使用<code>git</code>命令安装<code>NexT</code>开发主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h1 id="站点文件修改"><a href="#站点文件修改" class="headerlink" title="站点文件修改"></a>站点文件修改</h1><p>修改基本站点文件，博客根目录下的<code>_config.yml</code>文件。</p><h2 id="主页设计与作者名称"><a href="#主页设计与作者名称" class="headerlink" title="主页设计与作者名称"></a>主页设计与作者名称</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">TianTian的404私有库</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">一只有梦想会翻身的小咸鱼</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">一只有梦想会翻身的小咸鱼</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">TianTian</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure><h2 id="URL配置"><a href="#URL配置" class="headerlink" title="URL配置"></a>URL配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">https://liutiantian233.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:category/:year/:month/:title.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line">  <span class="string">技术:</span> <span class="string">tech</span></span><br><span class="line">  <span class="string">日常:</span> <span class="string">daily</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br></pre></td></tr></table></figure><h2 id="主页页数配置"><a href="#主页页数配置" class="headerlink" title="主页页数配置"></a>主页页数配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  order_by:</span> <span class="bullet">-date</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br></pre></td></tr></table></figure><h2 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><h2 id="部署地址"><a href="#部署地址" class="headerlink" title="部署地址"></a>部署地址</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/liutiantian233/liutiantian233.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h1 id="更改Mist主题外观侧边栏"><a href="#更改Mist主题外观侧边栏" class="headerlink" title="更改Mist主题外观侧边栏"></a>更改<code>Mist</code>主题外观侧边栏</h1><h2 id="sidebar-styl文件"><a href="#sidebar-styl文件" class="headerlink" title="sidebar.styl文件"></a><code>sidebar.styl</code>文件</h2><p>路径<code>/themes/next/source/css/_common/components/sidebar</code></p><p>第三行<code>right</code>改为<code>left</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="sidebar-toggle-styl文件"><a href="#sidebar-toggle-styl文件" class="headerlink" title="sidebar-toggle.styl文件"></a><code>sidebar-toggle.styl</code>文件</h2><p>路径<code>/themes/next/source/css/_common/components/sidebar</code></p><p>第三行<code>right</code>改为<code>left</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sidebar-toggle</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">left</span>: <span class="variable">$b2t</span>-position-right;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">45px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">14px</span>;</span><br></pre></td></tr></table></figure><h2 id="back-to-top-styl文件"><a href="#back-to-top-styl文件" class="headerlink" title="back-to-top.styl文件"></a><code>back-to-top.styl</code>文件</h2><p>路径<code>/themes/next/source/css/_common/components</code></p><p>第五行<code>right</code>改为<code>left</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="variable">$b2t</span>-position-bottom;</span><br><span class="line">  <span class="attribute">left</span>: <span class="variable">$b2t</span>-position-right;</span><br></pre></td></tr></table></figure><h2 id="motion-js文件"><a href="#motion-js文件" class="headerlink" title="motion.js文件"></a><code>motion.js</code>文件</h2><p>路径<code>/themes/next/source/js/src</code></p><p>将两处<code>paddingRight</code>改为<code>paddingLeft</code></p><h1 id="安装优化模块"><a href="#安装优化模块" class="headerlink" title="安装优化模块"></a>安装优化模块</h1><p>优化并搭载安装常用模块</p><h2 id="统计字数和阅读时间"><a href="#统计字数和阅读时间" class="headerlink" title="统计字数和阅读时间"></a><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">统计字数和阅读时间</a></h2><p>在根目录下运行终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>在根目录下的<code>_config.yml</code>文件增加以下语句</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在<code>next</code>主题目录下的<code>_config.yml</code>文件修改以下语句</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  item_text_total:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  awl:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  wpm:</span> <span class="number">280</span></span><br></pre></td></tr></table></figure><h2 id="分享模块"><a href="#分享模块" class="headerlink" title="分享模块"></a><a href="https://github.com/theme-next/theme-next-needmoreshare2" target="_blank" rel="noopener">分享模块</a></h2><p>在<code>next</code>主题目录下运行终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton</span><br></pre></td></tr></table></figure><p>在<code>next</code>主题目录下的<code>_config.yml</code>文件修改以下语句</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">needmoreshare2:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  postbottom:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  float:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="基础背景动画模块"><a href="#基础背景动画模块" class="headerlink" title="基础背景动画模块"></a><a href="https://github.com/theme-next/theme-next-canvas-nest" target="_blank" rel="noopener">基础背景动画模块</a></h2><p>在<code>next</code>主题目录下运行终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</span><br></pre></td></tr></table></figure><p>在<code>next</code>主题目录下的<code>_config.yml</code>文件修改以下语句</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  onmobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile or not</span></span><br><span class="line"><span class="attr">  color:</span> <span class="string">'0,0,255'</span> <span class="comment"># RGB values, use ',' to separate</span></span><br><span class="line"><span class="attr">  opacity:</span> <span class="number">0.5</span> <span class="comment"># the opacity of line: 0~1</span></span><br><span class="line"><span class="attr">  zIndex:</span> <span class="bullet">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line"><span class="attr">  count:</span> <span class="number">99</span> <span class="comment"># the number of lines</span></span><br></pre></td></tr></table></figure><h2 id="顶部阅读进度模块"><a href="#顶部阅读进度模块" class="headerlink" title="顶部阅读进度模块"></a><a href="https://github.com/theme-next/theme-next-reading-progress" target="_blank" rel="noopener">顶部阅读进度模块</a></h2><p>在<code>next</code>主题目录下运行终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress</span><br></pre></td></tr></table></figure><p>在<code>next</code>主题目录下的<code>_config.yml</code>文件修改以下语句</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  color:</span> <span class="string">"#37c6c0"</span></span><br><span class="line"><span class="attr">  height:</span> <span class="number">3</span><span class="string">px</span></span><br></pre></td></tr></table></figure><h2 id="加载进度模块"><a href="#加载进度模块" class="headerlink" title="加载进度模块"></a><a href="https://github.com/theme-next/theme-next-pace" target="_blank" rel="noopener">加载进度模块</a></h2><p>在<code>next</code>主题目录下运行终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pace source/lib/pace</span><br></pre></td></tr></table></figure><p>在<code>next</code>主题目录下的<code>_config.yml</code>文件修改以下语句</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-pace</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment"># pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom</span></span><br><span class="line"><span class="comment"># pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment"># pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimal</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-center-atom</span></span><br></pre></td></tr></table></figure><h2 id="安装RSS模块"><a href="#安装RSS模块" class="headerlink" title="安装RSS模块"></a>安装<code>RSS</code>模块</h2><p>在根目录下运行终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><h1 id="调用内部模块"><a href="#调用内部模块" class="headerlink" title="调用内部模块"></a>调用内部模块</h1><p>已安装的模块程序，可直接被调用。</p><h2 id="修改主题模式"><a href="#修改主题模式" class="headerlink" title="修改主题模式"></a>修改主题模式</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure><h2 id="菜单修改"><a href="#菜单修改" class="headerlink" title="菜单修改"></a>菜单修改</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure><h2 id="外部网站链接"><a href="#外部网站链接" class="headerlink" title="外部网站链接"></a>外部网站链接</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="attr">https://github.com/liutiantian233</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="string">邮箱:</span> <span class="attr">mailto:liutia20@msu.edu</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="string">微博:</span> <span class="attr">https://www.weibo.com/u/5912150206</span> <span class="string">||</span> <span class="string">weibo</span></span><br><span class="line">  <span class="string">知乎:</span> <span class="attr">https://www.zhihu.com/people/wo-de-hei-yan-jing-60/activities</span></span><br><span class="line">  <span class="string">哔哩哔哩:</span> <span class="attr">https://space.bilibili.com/32160272</span></span><br></pre></td></tr></table></figure><h2 id="友情链接模块"><a href="#友情链接模块" class="headerlink" title="友情链接模块"></a>友情链接模块</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">友情跳转链接</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">block</span></span><br><span class="line"><span class="comment">#links_layout: inline</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="string">千万互联:</span></span><br><span class="line">  <span class="string">孤独寂寞冷:</span></span><br><span class="line">  <span class="string">欢迎加入:</span></span><br></pre></td></tr></table></figure><h2 id="添加头像"><a href="#添加头像" class="headerlink" title="添加头像"></a>添加头像</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line">  <span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line">  <span class="comment"># You can also use other linking images.</span></span><br><span class="line"><span class="attr">  url:</span> <span class="attr">https://raw.githubusercontent.com/liutiantian233/Blog/master/head.png</span></span><br></pre></td></tr></table></figure><h2 id="左下角显示回到顶部和进度显示"><a href="#左下角显示回到顶部和进度显示" class="headerlink" title="左下角显示回到顶部和进度显示"></a>左下角显示回到顶部和进度显示</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span></span><br><span class="line"><span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line"><span class="comment"># Back to top in sidebar.</span></span><br><span class="line"><span class="attr">b2t:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line"><span class="attr">onmobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="不蒜子统计模块"><a href="#不蒜子统计模块" class="headerlink" title="不蒜子统计模块"></a>不蒜子统计模块</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show Views/Visitors of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_visitors:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  total_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_views_icon:</span> <span class="string">eye</span></span><br><span class="line"><span class="attr">  post_views:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure><h2 id="修改建站时间"><a href="#修改建站时间" class="headerlink" title="修改建站时间"></a>修改建站时间</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup.</span></span><br><span class="line">  <span class="comment"># If not defined, current year will be used.</span></span><br><span class="line"><span class="attr">  since:</span> <span class="number">2018</span></span><br></pre></td></tr></table></figure><h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line"><span class="attr">  license:</span> <span class="string">by-nc-sa</span></span><br><span class="line"><span class="attr">  sidebar:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  post:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="添加Follow-me-on-GitHub"><a href="#添加Follow-me-on-GitHub" class="headerlink" title="添加Follow me on GitHub"></a>添加<code>Follow me on GitHub</code></h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Follow me on GitHub banner in right-top corner.</span></span><br><span class="line"><span class="comment"># Usage: `permalink || title`</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target permalink.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the title and aria-label name.</span></span><br><span class="line"><span class="attr">github_banner:</span> <span class="attr">https://github.com/liutiantian233</span> <span class="string">||</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure><h2 id="自动弹出左边栏"><a href="#自动弹出左边栏" class="headerlink" title="自动弹出左边栏"></a>自动弹出左边栏</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#display: post</span></span><br><span class="line"><span class="attr">display:</span> <span class="string">always</span></span><br><span class="line"><span class="comment">#display: hide</span></span><br><span class="line"><span class="comment">#display: remove</span></span><br></pre></td></tr></table></figure><h1 id="关于建站补充和Debug"><a href="#关于建站补充和Debug" class="headerlink" title="关于建站补充和Debug"></a>关于建站补充和Debug</h1><h2 id="添加关于页面"><a href="#添加关于页面" class="headerlink" title="添加关于页面"></a>添加关于页面</h2><p>在根目录下运行终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><p>修改<code>index.md</code>为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">关于</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-13</span> <span class="number">13</span><span class="string">:00:00</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"about"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="关于增加分类页"><a href="#关于增加分类页" class="headerlink" title="关于增加分类页"></a>关于增加分类页</h2><p>在根目录下运行终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>修改<code>index.md</code>为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-10</span> <span class="number">12</span><span class="string">:00:00</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"categories"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="关于增加标签页"><a href="#关于增加标签页" class="headerlink" title="关于增加标签页"></a>关于增加标签页</h2><p>在根目录下运行终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>修改<code>index.md</code>为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-10</span> <span class="number">12</span><span class="string">:00:00</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h2><p>在根目录下运行终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><strong>后期测试中会逐步补充</strong></p><p><strong>关注本站持续更新</strong></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo中文官方手册</a></p><p><a href="https://github.com/theme-next" target="_blank" rel="noopener">NexT 6.0 官方GitHub库</a></p><p><a href="https://theme-next.iissnan.com" target="_blank" rel="noopener">NexT 5.0 系列官方手册</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术-tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建-Blog-building </tag>
            
            <tag> 博客模块-Blog-module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的树洞 MY Tree Hole</title>
      <link href="/daily/2018/tree-hole.html"/>
      <url>/daily/2018/tree-hole.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言-Foreword"><a href="#前言-Foreword" class="headerlink" title="前言 Foreword"></a>前言 Foreword</h1><p><img src="https://raw.githubusercontent.com/liutiantian233/Blog/master/20181230/about-me-1.jpg" alt></p><p>这是我2018年底写的第一篇博客，很多想说的，想做的，都暂时写在这里吧，搭建这个博客起初的想法不过是一丝丝小小的兴趣。但当逐渐开始搭建的时候，才发现不是那么的简单，到目前，终于正式完成了，也算是一个打卡吧。</p><a id="more"></a><h1 id="2019年2月12日"><a href="#2019年2月12日" class="headerlink" title="2019年2月12日"></a>2019年2月12日</h1><p>其实作为留学生压力还是有的。大一上学期忙忙碌碌，拿了一个不算糟糕的成绩。但总是觉得缺了点什么一样。于是乎，大一下学期开始集邮式的找实习，不管是校区内公司还是校区外，甚至是实验室的助手也递交过，毫无音讯，不了了之。今天是19年的2月12日，这学期物理化学的第一场考试才告一段落，然而后天就是专业课考试了，2月14号，仔细想想还真是讽刺。</p><p>其实一开始心态还是崩的，上学期期末的计划基本全部凉凉，人心呀，总是让人那么无奈。很尽力得试图改变心态，佛系少年。现在跨出了第一步，删了所有微博，所有空间，所有朋友圈。先从心态上一步一步来吧。至于感情，<strong>抑制抑制再抑制</strong>，直截了当，那就当一个渣男好了。</p><p>物理，物理实验，化学，化学实验，人类学，计算机专业课，前五者。不过而而，专心攻读C++吧！！！学校里两位刘教授的邮件还在幻想着回复，梦校可是UW，可是CMU啊，那些已经在SCI发表学术论文的学长，我不相信我比他们差。我一定，一定，一定！！！</p><p>我也不知道这种渴望是好是坏，我也意识到这种渴望已经影响了我很久，我到底要不要改变，我也很害怕它会害了我。我现在正在坐在学校的自习室，学姐的电话还在连着麦，很乱，真的很乱！</p><p>学姐的电话还没挂，还是继续吧，罗马不是一天建成的，我还是先简简单单规划一下以后的作息和时间吧，在手机上！定时！第一步生活要规律，早睡早起，吃早饭，午饭，晚饭。今天是周二，下一篇树洞是下周，这是我对我的第一个小小的要求。每天7点醒，10点半睡，周五早课除外，早上洗澡之后去吃早饭，之后看书学习整理笔记和作业，周一周三吃完午饭去上课，周二周四吃完饭可以去跑跑步，晚饭可有可无，一切按部就班！</p><p>行吧，现在已经是九点四十了。这些东西写出来就好一点了吧，尽管我知道还有很多憋在心里，但，已经写出了这么多，不是很好了已经！加油，阿莱！</p><h1 id="2019年2月21日"><a href="#2019年2月21日" class="headerlink" title="2019年2月21日"></a>2019年2月21日</h1><p>今天是周四，这周怎么说吧。其实还行，学校两位刘教授的实验室是去不了了，但还是有一个关于教育的课题实验组招收本科生，下周一正式上岗，尽管还不确定到底是怎么用python，看介绍来说，类似于python爬虫吧。我有信心！哈哈哈！</p><p>博客还是正常更新，这学期的C++教程写完就是下学期的离散数学等等。都说300篇博客是个分水岭，3000小时是个零界点，要我说，哈哈，不过坚持二字。倒没什么想法。昨天我还在想，作为一个留学的计算机本科生，怎么过才算是最有意义，最有价值。也可能这么说，留学生的青春怎么才会让人难忘，其实今天也算是有了答案吧，跟随自己的内心吧。</p>]]></content>
      
      
      <categories>
          
          <category> 日常-daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吐槽项-bb-for-bb </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
